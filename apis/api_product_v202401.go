/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"
    "reflect"

    "tiktokshop/open/sdk_golang/models/product/v202401"
)


// ProductV202401APIService ProductV202401API service
type ProductV202401APIService service

type ApiProduct202401ListingSchemasGetRequest struct {
    ctx context.Context
    ApiService *ProductV202401APIService
    categoryIds *[]int32
    xTtsAccessToken *string
    contentType *string
    locale *string
    categoryVersion *string
}

// The interface returns the field requirements for creating a product. By providing the leaf category ID, you can obtain the field information and input methods for the product creation requirements.
func (r ApiProduct202401ListingSchemasGetRequest) CategoryIds(categoryIds []int32) ApiProduct202401ListingSchemasGetRequest {
    r.categoryIds = &categoryIds
    return r
}
// 
func (r ApiProduct202401ListingSchemasGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiProduct202401ListingSchemasGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiProduct202401ListingSchemasGetRequest) ContentType(contentType string) ApiProduct202401ListingSchemasGetRequest {
    r.contentType = &contentType
    return r
}
// Category information will be returned in the corresponding language based on the specified locale. If no locale is provided, the default locale of the store will be used.  The currently supported locales include: en-GB, en-US, id-ID, ms-MY, th-TH, vi-VN, zh-CN. Use BCP-47 language codes, such as &#39;en-US&#39; or &#39;id&#39;. For more details, please refer to http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
func (r ApiProduct202401ListingSchemasGetRequest) Locale(locale string) ApiProduct202401ListingSchemasGetRequest {
    r.locale = &locale
    return r
}
// The version id of the category tree.The new version id is \&quot;v2\&quot; and will return data from our new 7-level category tree.The old version id is \&quot;v1\&quot; and will return data from the current 3-level category tree.The old version of category data will be given by default.
func (r ApiProduct202401ListingSchemasGetRequest) CategoryVersion(categoryVersion string) ApiProduct202401ListingSchemasGetRequest {
    r.categoryVersion = &categoryVersion
    return r
}
func (r ApiProduct202401ListingSchemasGetRequest) Execute() (*product_v202401.Product202401ListingSchemasResponse, *http.Response, error) {
    return r.ApiService.Product202401ListingSchemasGetExecute(r)
}

/*
Product202401ListingSchemasGet ListingSchemas
The interface returns the field requirements for creating a product. By providing the leaf category ID, you can obtain the field information and input methods for the product creation requirements.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiProduct202401ListingSchemasGetRequest
*/
func (a *ProductV202401APIService) Product202401ListingSchemasGet(ctx context.Context) ApiProduct202401ListingSchemasGetRequest {
    return ApiProduct202401ListingSchemasGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Product202401ListingSchemasResponse
func (a *ProductV202401APIService) Product202401ListingSchemasGetExecute(r ApiProduct202401ListingSchemasGetRequest) (*product_v202401.Product202401ListingSchemasResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *product_v202401.Product202401ListingSchemasResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductV202401APIService.Product202401ListingSchemasGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/product/202401/listing_schemas"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.categoryIds == nil {
        return localVarReturnValue, nil, reportError("categoryIds is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    {
        t := *r.categoryIds
        if reflect.TypeOf(t).Kind() == reflect.Slice {
            s := reflect.ValueOf(t)
            for i := 0; i < s.Len(); i++ {
                parameterAddToHeaderOrQuery(localVarQueryParams, "category_ids", s.Index(i).Interface(), "multi")
            }
        } else {
            parameterAddToHeaderOrQuery(localVarQueryParams, "category_ids", t, "multi")
        }
    }
    if r.locale != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
    }
    if r.categoryVersion != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "category_version", r.categoryVersion, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
