/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"
    "strings"

    "tiktokshop/open/sdk_golang/models/order/v202406"
)


// OrderV202406APIService OrderV202406API service
type OrderV202406APIService service

type ApiOrder202406OrdersExternalOrderSearchPostRequest struct {
    ctx context.Context
    ApiService *OrderV202406APIService
    platform *string
    externalOrderId *string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// The alias of your external order management system (OMS). Possible values: - SHOPIFY - WOOCOMMERCE - BIGCOMMERCE - MAGENTO - SALESFORCE_COMMERCE_CLOUD - CHANNEL_ADVISOR - AMAZON - ORDER_MANAGEMENT_SYSTEM - WAREHOUSE_MANAGEMENT_SYSTEM - ERP_SYSTEM
func (r ApiOrder202406OrdersExternalOrderSearchPostRequest) Platform(platform string) ApiOrder202406OrdersExternalOrderSearchPostRequest {
    r.platform = &platform
    return r
}
// Order ID in your OMS.
func (r ApiOrder202406OrdersExternalOrderSearchPostRequest) ExternalOrderId(externalOrderId string) ApiOrder202406OrdersExternalOrderSearchPostRequest {
    r.externalOrderId = &externalOrderId
    return r
}
// 
func (r ApiOrder202406OrdersExternalOrderSearchPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiOrder202406OrdersExternalOrderSearchPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiOrder202406OrdersExternalOrderSearchPostRequest) ContentType(contentType string) ApiOrder202406OrdersExternalOrderSearchPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiOrder202406OrdersExternalOrderSearchPostRequest) ShopCipher(shopCipher string) ApiOrder202406OrdersExternalOrderSearchPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiOrder202406OrdersExternalOrderSearchPostRequest) Execute() (*order_v202406.Order202406SearchOrderByExternalOrderReferenceResponse, *http.Response, error) {
    return r.ApiService.Order202406OrdersExternalOrderSearchPostExecute(r)
}

/*
Order202406OrdersExternalOrderSearchPost SearchOrderByExternalOrderReference
If you have used the `Add External Order References` API to sync information from your external order management system (OMS) to corresponding orders in TikTok Shop, you may call this API to search for order information in TikTok Shop based on information in your OMS.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiOrder202406OrdersExternalOrderSearchPostRequest
*/
func (a *OrderV202406APIService) Order202406OrdersExternalOrderSearchPost(ctx context.Context) ApiOrder202406OrdersExternalOrderSearchPostRequest {
    return ApiOrder202406OrdersExternalOrderSearchPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Order202406SearchOrderByExternalOrderReferenceResponse
func (a *OrderV202406APIService) Order202406OrdersExternalOrderSearchPostExecute(r ApiOrder202406OrdersExternalOrderSearchPostRequest) (*order_v202406.Order202406SearchOrderByExternalOrderReferenceResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *order_v202406.Order202406SearchOrderByExternalOrderReferenceResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderV202406APIService.Order202406OrdersExternalOrderSearchPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/order/202406/orders/external_order_search"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.platform == nil {
        return localVarReturnValue, nil, reportError("platform is required and must be specified")
    }
    if r.externalOrderId == nil {
        return localVarReturnValue, nil, reportError("externalOrderId is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    parameterAddToHeaderOrQuery(localVarQueryParams, "platform", r.platform, "")
    parameterAddToHeaderOrQuery(localVarQueryParams, "external_order_id", r.externalOrderId, "")
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrder202406OrdersExternalOrdersPostRequest struct {
    ctx context.Context
    ApiService *OrderV202406APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    order202406AddExternalOrderReferencesRequestBody *order_v202406.Order202406AddExternalOrderReferencesRequestBody
}

// 
func (r ApiOrder202406OrdersExternalOrdersPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiOrder202406OrdersExternalOrdersPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiOrder202406OrdersExternalOrdersPostRequest) ContentType(contentType string) ApiOrder202406OrdersExternalOrdersPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiOrder202406OrdersExternalOrdersPostRequest) ShopCipher(shopCipher string) ApiOrder202406OrdersExternalOrdersPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiOrder202406OrdersExternalOrdersPostRequest) Order202406AddExternalOrderReferencesRequestBody(order202406AddExternalOrderReferencesRequestBody order_v202406.Order202406AddExternalOrderReferencesRequestBody) ApiOrder202406OrdersExternalOrdersPostRequest {
    r.order202406AddExternalOrderReferencesRequestBody = &order202406AddExternalOrderReferencesRequestBody
    return r
}
func (r ApiOrder202406OrdersExternalOrdersPostRequest) Execute() (*order_v202406.Order202406AddExternalOrderReferencesResponse, *http.Response, error) {
    return r.ApiService.Order202406OrdersExternalOrdersPostExecute(r)
}

/*
Order202406OrdersExternalOrdersPost AddExternalOrderReferences
If you are using your own external OMS (order management system) to manage TikTok Shop orders, the corresponding order IDs between your OMS and TikTok Shop may be different.
Use this endpoint to attach the information in your OMS to the correct order(s) in TikTok Shop for further reference.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiOrder202406OrdersExternalOrdersPostRequest
*/
func (a *OrderV202406APIService) Order202406OrdersExternalOrdersPost(ctx context.Context) ApiOrder202406OrdersExternalOrdersPostRequest {
    return ApiOrder202406OrdersExternalOrdersPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Order202406AddExternalOrderReferencesResponse
func (a *OrderV202406APIService) Order202406OrdersExternalOrdersPostExecute(r ApiOrder202406OrdersExternalOrdersPostRequest) (*order_v202406.Order202406AddExternalOrderReferencesResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *order_v202406.Order202406AddExternalOrderReferencesResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderV202406APIService.Order202406OrdersExternalOrdersPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/order/202406/orders/external_orders"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.order202406AddExternalOrderReferencesRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrder202406OrdersOrderIdExternalOrdersGetRequest struct {
    ctx context.Context
    ApiService *OrderV202406APIService
    orderId string
    platform *string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// The alias of your external order management system (OMS).  Possible values: - SHOPIFY - WOOCOMMERCE - BIGCOMMERCE - MAGENTO - SALESFORCE_COMMERCE_CLOUD - CHANNEL_ADVISOR - AMAZON - ORDER_MANAGEMENT_SYSTEM - WAREHOUSE_MANAGEMENT_SYSTEM - ERP_SYSTEM
func (r ApiOrder202406OrdersOrderIdExternalOrdersGetRequest) Platform(platform string) ApiOrder202406OrdersOrderIdExternalOrdersGetRequest {
    r.platform = &platform
    return r
}
// 
func (r ApiOrder202406OrdersOrderIdExternalOrdersGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiOrder202406OrdersOrderIdExternalOrdersGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiOrder202406OrdersOrderIdExternalOrdersGetRequest) ContentType(contentType string) ApiOrder202406OrdersOrderIdExternalOrdersGetRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiOrder202406OrdersOrderIdExternalOrdersGetRequest) ShopCipher(shopCipher string) ApiOrder202406OrdersOrderIdExternalOrdersGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiOrder202406OrdersOrderIdExternalOrdersGetRequest) Execute() (*order_v202406.Order202406GetExternalOrderReferencesResponse, *http.Response, error) {
    return r.ApiService.Order202406OrdersOrderIdExternalOrdersGetExecute(r)
}

/*
Order202406OrdersOrderIdExternalOrdersGet GetExternalOrderReferences
If you have used the `Add External Order References` API to sync order information between your external order management system (OMS) and TikTok Shop, you may call this API to get information on the synced orders.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param orderId The unique identifier for a TikTok Shop order.
@return ApiOrder202406OrdersOrderIdExternalOrdersGetRequest
*/
func (a *OrderV202406APIService) Order202406OrdersOrderIdExternalOrdersGet(ctx context.Context, orderId string) ApiOrder202406OrdersOrderIdExternalOrdersGetRequest {
    return ApiOrder202406OrdersOrderIdExternalOrdersGetRequest{
        ApiService: a,
        ctx: ctx,
        orderId: orderId,
    }
}

// Execute executes the request
//  @return Order202406GetExternalOrderReferencesResponse
func (a *OrderV202406APIService) Order202406OrdersOrderIdExternalOrdersGetExecute(r ApiOrder202406OrdersOrderIdExternalOrdersGetRequest) (*order_v202406.Order202406GetExternalOrderReferencesResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *order_v202406.Order202406GetExternalOrderReferencesResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderV202406APIService.Order202406OrdersOrderIdExternalOrdersGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/order/202406/orders/{order_id}/external_orders"
    localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.platform == nil {
        return localVarReturnValue, nil, reportError("platform is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    parameterAddToHeaderOrQuery(localVarQueryParams, "platform", r.platform, "")
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
