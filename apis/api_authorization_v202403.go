/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"

    "tiktokshop/open/sdk_golang/models/authorization/v202403"
)


// AuthorizationV202403APIService AuthorizationV202403API service
type AuthorizationV202403APIService service

type ApiAuthorization202403ShopsDeleteRequest struct {
    ctx context.Context
    ApiService *AuthorizationV202403APIService
    shopCipher *string
    xTtsAccessToken *string
    contentType *string
}

// Shop_cipher is required for cross-border shops, and optional for local shops. It&#39;s unique for each shop. Get the this property from the Get Authorized Shop API dynamically. Use this property to pass shop information in requesting the API. Failure in passing the correct value when requesting the API for cross-border shops will return incorrect response.
func (r ApiAuthorization202403ShopsDeleteRequest) ShopCipher(shopCipher string) ApiAuthorization202403ShopsDeleteRequest {
    r.shopCipher = &shopCipher
    return r
}
// 
func (r ApiAuthorization202403ShopsDeleteRequest) XTtsAccessToken(xTtsAccessToken string) ApiAuthorization202403ShopsDeleteRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAuthorization202403ShopsDeleteRequest) ContentType(contentType string) ApiAuthorization202403ShopsDeleteRequest {
    r.contentType = &contentType
    return r
}
func (r ApiAuthorization202403ShopsDeleteRequest) Execute() (*authorization_v202403.Authorization202403DeauthorizeShopResponse, *http.Response, error) {
    return r.ApiService.Authorization202403ShopsDeleteExecute(r)
}

/*
Authorization202403ShopsDelete DeauthorizeShop
This API is used  for developers to deauthorize a shop and notify the seller about this action by email

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAuthorization202403ShopsDeleteRequest
*/
func (a *AuthorizationV202403APIService) Authorization202403ShopsDelete(ctx context.Context) ApiAuthorization202403ShopsDeleteRequest {
    return ApiAuthorization202403ShopsDeleteRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Authorization202403DeauthorizeShopResponse
func (a *AuthorizationV202403APIService) Authorization202403ShopsDeleteExecute(r ApiAuthorization202403ShopsDeleteRequest) (*authorization_v202403.Authorization202403DeauthorizeShopResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodDelete
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *authorization_v202403.Authorization202403DeauthorizeShopResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationV202403APIService.Authorization202403ShopsDelete")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/authorization/202403/shops"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.shopCipher == nil {
        return localVarReturnValue, nil, reportError("shopCipher is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
