/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"
    "strings"
    "os"
    "reflect"

    "tiktokshop/open/sdk_golang/models/fulfillment/v202309"
)


// FulfillmentV202309APIService FulfillmentV202309API service
type FulfillmentV202309APIService service

type ApiFulfillment202309CombinablePackagesSearchGetRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    pageSize *int32
    xTtsAccessToken *string
    contentType *string
    pageToken *string
    shopCipher *string
}

// The number of results to be returned per page. Valid range: [1-50].
func (r ApiFulfillment202309CombinablePackagesSearchGetRequest) PageSize(pageSize int32) ApiFulfillment202309CombinablePackagesSearchGetRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiFulfillment202309CombinablePackagesSearchGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309CombinablePackagesSearchGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFulfillment202309CombinablePackagesSearchGetRequest) ContentType(contentType string) ApiFulfillment202309CombinablePackagesSearchGetRequest {
    r.contentType = &contentType
    return r
}
// An opaque token used to retrieve the next page of a paginated result set. Retrieve this value from the result of the &#x60;next_page_token&#x60; from a previous response. It is not needed for the first page. 
func (r ApiFulfillment202309CombinablePackagesSearchGetRequest) PageToken(pageToken string) ApiFulfillment202309CombinablePackagesSearchGetRequest {
    r.pageToken = &pageToken
    return r
}
// 
func (r ApiFulfillment202309CombinablePackagesSearchGetRequest) ShopCipher(shopCipher string) ApiFulfillment202309CombinablePackagesSearchGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFulfillment202309CombinablePackagesSearchGetRequest) Execute() (*fulfillment_v202309.Fulfillment202309SearchCombinablePackagesResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309CombinablePackagesSearchGetExecute(r)
}

/*
Fulfillment202309CombinablePackagesSearchGet SearchCombinablePackages
Use this API to query orders eligible for combined shipping. 

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiFulfillment202309CombinablePackagesSearchGetRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309CombinablePackagesSearchGet(ctx context.Context) ApiFulfillment202309CombinablePackagesSearchGetRequest {
    return ApiFulfillment202309CombinablePackagesSearchGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Fulfillment202309SearchCombinablePackagesResponse
func (a *FulfillmentV202309APIService) Fulfillment202309CombinablePackagesSearchGetExecute(r ApiFulfillment202309CombinablePackagesSearchGetRequest) (*fulfillment_v202309.Fulfillment202309SearchCombinablePackagesResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309SearchCombinablePackagesResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309CombinablePackagesSearchGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/combinable_packages/search"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.pageSize == nil {
        return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309FilesUploadPostRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    data *os.File
    name *string
}

// 
func (r ApiFulfillment202309FilesUploadPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309FilesUploadPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: multipart/form-data
func (r ApiFulfillment202309FilesUploadPostRequest) ContentType(contentType string) ApiFulfillment202309FilesUploadPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFulfillment202309FilesUploadPostRequest) ShopCipher(shopCipher string) ApiFulfillment202309FilesUploadPostRequest {
    r.shopCipher = &shopCipher
    return r
}
// PDF file data to be uploaded to TikTok Shop.  Prerequisitesï¼š - Only &#x60;PDF&#x60; file format is supported. - Original file size must not exceed 10MB.
func (r ApiFulfillment202309FilesUploadPostRequest) Data(data *os.File) ApiFulfillment202309FilesUploadPostRequest {
    r.data = data
    return r
}
// The name of the uploaded file. The file name must include the file type.
func (r ApiFulfillment202309FilesUploadPostRequest) Name(name string) ApiFulfillment202309FilesUploadPostRequest {
    r.name = &name
    return r
}
func (r ApiFulfillment202309FilesUploadPostRequest) Execute() (*fulfillment_v202309.Fulfillment202309FulfillmentUploadDeliveryFileResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309FilesUploadPostExecute(r)
}

/*
Fulfillment202309FilesUploadPost FulfillmentUploadDeliveryFile
This API is used for the seller to upload the proof of delivery file for a package, and to generate the URL of the corresponding file. The generated URL is used for the [Update Package Delivery Status API](https://partner.tiktokshop.com/docv2/page/650aa332c16ffe02b8f0ba82?external_id=650aa332c16ffe02b8f0ba82). 

This API only supports uploading qualification files in `PDF` format. The file size can not exceed 10MB.

Note: Only sellers utilizing the SOF (Seller Own Fleet) capability can use this API. 

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiFulfillment202309FilesUploadPostRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309FilesUploadPost(ctx context.Context) ApiFulfillment202309FilesUploadPostRequest {
    return ApiFulfillment202309FilesUploadPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Fulfillment202309FulfillmentUploadDeliveryFileResponse
func (a *FulfillmentV202309APIService) Fulfillment202309FilesUploadPostExecute(r ApiFulfillment202309FilesUploadPostRequest) (*fulfillment_v202309.Fulfillment202309FulfillmentUploadDeliveryFileResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309FulfillmentUploadDeliveryFileResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309FilesUploadPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/files/upload"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"multipart/form-data"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    var dataLocalVarFormFileName string
    var dataLocalVarFileName     string
    var dataLocalVarFileBytes    []byte

    dataLocalVarFormFileName = "data"
    dataLocalVarFile := r.data

    if dataLocalVarFile != nil {
        fbs, _ := io.ReadAll(dataLocalVarFile)

        dataLocalVarFileBytes = fbs
        dataLocalVarFileName = dataLocalVarFile.Name()
        dataLocalVarFile.Close()
        formFiles = append(formFiles, formFile{fileBytes: dataLocalVarFileBytes, fileName: dataLocalVarFileName, formFileName: dataLocalVarFormFileName})
    }
    if r.name != nil {
        parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "")
    }
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309ImagesUploadPostRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    data *os.File
}

// 
func (r ApiFulfillment202309ImagesUploadPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309ImagesUploadPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: multipart/form-data
func (r ApiFulfillment202309ImagesUploadPostRequest) ContentType(contentType string) ApiFulfillment202309ImagesUploadPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFulfillment202309ImagesUploadPostRequest) ShopCipher(shopCipher string) ApiFulfillment202309ImagesUploadPostRequest {
    r.shopCipher = &shopCipher
    return r
}
// Image file data to be uploaded to TikTok Shop. The picture file is a string generated by base64 encoding. Prerequisitesï¼š - Image format must be &#x60;JPG&#x60;, &#x60;JPEG&#x60;, or &#x60;PNG&#x60;. - Image resolution must be between 100 x 100px and 20000 x 20000px. - Image size must not exceed 5MB.
func (r ApiFulfillment202309ImagesUploadPostRequest) Data(data *os.File) ApiFulfillment202309ImagesUploadPostRequest {
    r.data = data
    return r
}
func (r ApiFulfillment202309ImagesUploadPostRequest) Execute() (*fulfillment_v202309.Fulfillment202309FulfillmentUploadDeliveryImageResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309ImagesUploadPostExecute(r)
}

/*
Fulfillment202309ImagesUploadPost FulfillmentUploadDeliveryImage
This API is used for the seller to upload the proof of delivery image for a package, and to generate the URL of the corresponding file. The generated URL is used in the [Update Package Delivery Status API](https://partner.tiktokshop.com/docv2/page/650aa332c16ffe02b8f0ba82?external_id=650aa332c16ffe02b8f0ba82) to indicate that the parcel has been delivered. 

Usage requirements:
- The image format must be `JPEG`, `PNG`, or `JPG`. 
- The image size can not exceed 5MB.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiFulfillment202309ImagesUploadPostRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309ImagesUploadPost(ctx context.Context) ApiFulfillment202309ImagesUploadPostRequest {
    return ApiFulfillment202309ImagesUploadPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Fulfillment202309FulfillmentUploadDeliveryImageResponse
func (a *FulfillmentV202309APIService) Fulfillment202309ImagesUploadPostExecute(r ApiFulfillment202309ImagesUploadPostRequest) (*fulfillment_v202309.Fulfillment202309FulfillmentUploadDeliveryImageResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309FulfillmentUploadDeliveryImageResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309ImagesUploadPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/images/upload"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"multipart/form-data"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    var dataLocalVarFormFileName string
    var dataLocalVarFileName     string
    var dataLocalVarFileBytes    []byte

    dataLocalVarFormFileName = "data"
    dataLocalVarFile := r.data

    if dataLocalVarFile != nil {
        fbs, _ := io.ReadAll(dataLocalVarFile)

        dataLocalVarFileBytes = fbs
        dataLocalVarFileName = dataLocalVarFile.Name()
        dataLocalVarFile.Close()
        formFiles = append(formFiles, formFile{fileBytes: dataLocalVarFileBytes, fileName: dataLocalVarFileName, formFileName: dataLocalVarFormFileName})
    }
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309OrdersOrderIdHandoverTimeSlotsGetRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    orderId string
    xTtsAccessToken *string
    contentType *string
    orderLineItemIds *[]string
    shopCipher *string
}

// 
func (r ApiFulfillment202309OrdersOrderIdHandoverTimeSlotsGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309OrdersOrderIdHandoverTimeSlotsGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFulfillment202309OrdersOrderIdHandoverTimeSlotsGetRequest) ContentType(contentType string) ApiFulfillment202309OrdersOrderIdHandoverTimeSlotsGetRequest {
    r.contentType = &contentType
    return r
}
// Order line item ID list
func (r ApiFulfillment202309OrdersOrderIdHandoverTimeSlotsGetRequest) OrderLineItemIds(orderLineItemIds []string) ApiFulfillment202309OrdersOrderIdHandoverTimeSlotsGetRequest {
    r.orderLineItemIds = &orderLineItemIds
    return r
}
// 
func (r ApiFulfillment202309OrdersOrderIdHandoverTimeSlotsGetRequest) ShopCipher(shopCipher string) ApiFulfillment202309OrdersOrderIdHandoverTimeSlotsGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFulfillment202309OrdersOrderIdHandoverTimeSlotsGetRequest) Execute() (*fulfillment_v202309.Fulfillment202309GetHandoverTimeslotsResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309OrdersOrderIdHandoverTimeSlotsGetExecute(r)
}

/*
Fulfillment202309OrdersOrderIdHandoverTimeSlotsGet GetHandoverTimeslots
Use this API to retrieve the time slots available for pickup, drop off or van collection for the seller's specified package by using order ID and order line item ID.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param orderId TikTok shop order ID.
@return ApiFulfillment202309OrdersOrderIdHandoverTimeSlotsGetRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309OrdersOrderIdHandoverTimeSlotsGet(ctx context.Context, orderId string) ApiFulfillment202309OrdersOrderIdHandoverTimeSlotsGetRequest {
    return ApiFulfillment202309OrdersOrderIdHandoverTimeSlotsGetRequest{
        ApiService: a,
        ctx: ctx,
        orderId: orderId,
    }
}

// Execute executes the request
//  @return Fulfillment202309GetHandoverTimeslotsResponse
func (a *FulfillmentV202309APIService) Fulfillment202309OrdersOrderIdHandoverTimeSlotsGetExecute(r ApiFulfillment202309OrdersOrderIdHandoverTimeSlotsGetRequest) (*fulfillment_v202309.Fulfillment202309GetHandoverTimeslotsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309GetHandoverTimeslotsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309OrdersOrderIdHandoverTimeSlotsGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/orders/{order_id}/handover_time_slots"
    localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.orderLineItemIds != nil {
        t := *r.orderLineItemIds
        if reflect.TypeOf(t).Kind() == reflect.Slice {
            s := reflect.ValueOf(t)
            for i := 0; i < s.Len(); i++ {
                parameterAddToHeaderOrQuery(localVarQueryParams, "order_line_item_ids", s.Index(i).Interface(), "multi")
            }
        } else {
            parameterAddToHeaderOrQuery(localVarQueryParams, "order_line_item_ids", t, "multi")
        }
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309OrdersOrderIdPackagesPostRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    orderId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    fulfillment202309MarkPackageAsShippedRequestBody *fulfillment_v202309.Fulfillment202309MarkPackageAsShippedRequestBody
}

// 
func (r ApiFulfillment202309OrdersOrderIdPackagesPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309OrdersOrderIdPackagesPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFulfillment202309OrdersOrderIdPackagesPostRequest) ContentType(contentType string) ApiFulfillment202309OrdersOrderIdPackagesPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFulfillment202309OrdersOrderIdPackagesPostRequest) ShopCipher(shopCipher string) ApiFulfillment202309OrdersOrderIdPackagesPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFulfillment202309OrdersOrderIdPackagesPostRequest) Fulfillment202309MarkPackageAsShippedRequestBody(fulfillment202309MarkPackageAsShippedRequestBody fulfillment_v202309.Fulfillment202309MarkPackageAsShippedRequestBody) ApiFulfillment202309OrdersOrderIdPackagesPostRequest {
    r.fulfillment202309MarkPackageAsShippedRequestBody = &fulfillment202309MarkPackageAsShippedRequestBody
    return r
}
func (r ApiFulfillment202309OrdersOrderIdPackagesPostRequest) Execute() (*fulfillment_v202309.Fulfillment202309MarkPackageAsShippedResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309OrdersOrderIdPackagesPostExecute(r)
}

/*
Fulfillment202309OrdersOrderIdPackagesPost MarkPackageAsShipped
**This API is currently exclusive to the following markets: US, UK, ES, IE.**

This API is for sellers who fulfill orders through their own selected/preferred logistics carrier, and allows sellers to upload valid package information (items in packages, shipping provider information, and tracking number) orders/order line items to TikTok Shop. Use [Get Shipping Providers API](https://partner.tiktokshop.com/docv2/page/650aa48d4a0bb702c06d85cd?external_id=650aa48d4a0bb702c06d85cd) to retrieve the `shipping_provider_id` for shipping providers.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param orderId 
@return ApiFulfillment202309OrdersOrderIdPackagesPostRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309OrdersOrderIdPackagesPost(ctx context.Context, orderId string) ApiFulfillment202309OrdersOrderIdPackagesPostRequest {
    return ApiFulfillment202309OrdersOrderIdPackagesPostRequest{
        ApiService: a,
        ctx: ctx,
        orderId: orderId,
    }
}

// Execute executes the request
//  @return Fulfillment202309MarkPackageAsShippedResponse
func (a *FulfillmentV202309APIService) Fulfillment202309OrdersOrderIdPackagesPostExecute(r ApiFulfillment202309OrdersOrderIdPackagesPostRequest) (*fulfillment_v202309.Fulfillment202309MarkPackageAsShippedResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309MarkPackageAsShippedResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309OrdersOrderIdPackagesPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/orders/{order_id}/packages"
    localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.fulfillment202309MarkPackageAsShippedRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309OrdersOrderIdShippingInfoUpdatePostRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    orderId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    fulfillment202309UpdateShippingInfoRequestBody *fulfillment_v202309.Fulfillment202309UpdateShippingInfoRequestBody
}

// 
func (r ApiFulfillment202309OrdersOrderIdShippingInfoUpdatePostRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309OrdersOrderIdShippingInfoUpdatePostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFulfillment202309OrdersOrderIdShippingInfoUpdatePostRequest) ContentType(contentType string) ApiFulfillment202309OrdersOrderIdShippingInfoUpdatePostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFulfillment202309OrdersOrderIdShippingInfoUpdatePostRequest) ShopCipher(shopCipher string) ApiFulfillment202309OrdersOrderIdShippingInfoUpdatePostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFulfillment202309OrdersOrderIdShippingInfoUpdatePostRequest) Fulfillment202309UpdateShippingInfoRequestBody(fulfillment202309UpdateShippingInfoRequestBody fulfillment_v202309.Fulfillment202309UpdateShippingInfoRequestBody) ApiFulfillment202309OrdersOrderIdShippingInfoUpdatePostRequest {
    r.fulfillment202309UpdateShippingInfoRequestBody = &fulfillment202309UpdateShippingInfoRequestBody
    return r
}
func (r ApiFulfillment202309OrdersOrderIdShippingInfoUpdatePostRequest) Execute() (*fulfillment_v202309.Fulfillment202309UpdateShippingInfoResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309OrdersOrderIdShippingInfoUpdatePostExecute(r)
}

/*
Fulfillment202309OrdersOrderIdShippingInfoUpdatePost UpdateShippingInfo
If the seller entered an incorrect tracking number, this API allows the seller to update the tracking number and shipping provider for an order that has already been shipped.

- This API is only applicable to orders (or packages) shipped by the seller.   
- It is only used to update the tracking number and shipping provider for packages that have already been shipped. 
- For orders that have been split for shipping, please use the [Update Package Shipping Info API](https://partner.tiktokshop.com/docv2/page/650aa666c16ffe02b8f1203c?external_id=650aa666c16ffe02b8f1203c). 

Please note that TikTok Shop only allows merchants to update shipping information within 72 hours after shipping.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param orderId TikTok Shop order ID.
@return ApiFulfillment202309OrdersOrderIdShippingInfoUpdatePostRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309OrdersOrderIdShippingInfoUpdatePost(ctx context.Context, orderId string) ApiFulfillment202309OrdersOrderIdShippingInfoUpdatePostRequest {
    return ApiFulfillment202309OrdersOrderIdShippingInfoUpdatePostRequest{
        ApiService: a,
        ctx: ctx,
        orderId: orderId,
    }
}

// Execute executes the request
//  @return Fulfillment202309UpdateShippingInfoResponse
func (a *FulfillmentV202309APIService) Fulfillment202309OrdersOrderIdShippingInfoUpdatePostExecute(r ApiFulfillment202309OrdersOrderIdShippingInfoUpdatePostRequest) (*fulfillment_v202309.Fulfillment202309UpdateShippingInfoResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309UpdateShippingInfoResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309OrdersOrderIdShippingInfoUpdatePost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/orders/{order_id}/shipping_info/update"
    localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.fulfillment202309UpdateShippingInfoRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309OrdersOrderIdShippingServicesQueryPostRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    orderId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    fulfillment202309GetEligibleShippingServiceRequestBody *fulfillment_v202309.Fulfillment202309GetEligibleShippingServiceRequestBody
}

// 
func (r ApiFulfillment202309OrdersOrderIdShippingServicesQueryPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309OrdersOrderIdShippingServicesQueryPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFulfillment202309OrdersOrderIdShippingServicesQueryPostRequest) ContentType(contentType string) ApiFulfillment202309OrdersOrderIdShippingServicesQueryPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFulfillment202309OrdersOrderIdShippingServicesQueryPostRequest) ShopCipher(shopCipher string) ApiFulfillment202309OrdersOrderIdShippingServicesQueryPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFulfillment202309OrdersOrderIdShippingServicesQueryPostRequest) Fulfillment202309GetEligibleShippingServiceRequestBody(fulfillment202309GetEligibleShippingServiceRequestBody fulfillment_v202309.Fulfillment202309GetEligibleShippingServiceRequestBody) ApiFulfillment202309OrdersOrderIdShippingServicesQueryPostRequest {
    r.fulfillment202309GetEligibleShippingServiceRequestBody = &fulfillment202309GetEligibleShippingServiceRequestBody
    return r
}
func (r ApiFulfillment202309OrdersOrderIdShippingServicesQueryPostRequest) Execute() (*fulfillment_v202309.Fulfillment202309GetEligibleShippingServiceResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309OrdersOrderIdShippingServicesQueryPostExecute(r)
}

/*
Fulfillment202309OrdersOrderIdShippingServicesQueryPost GetEligibleShippingService
Use this API ( for US ) to query the list of available shipping services when specifying packages' size or weight. The shipping fee and delivery time is an estimate only and is based on the package dimensions and weight you provided. Options listed may differ if you change the package attributes at the time of shipping.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param orderId TikTok Shop order ID
@return ApiFulfillment202309OrdersOrderIdShippingServicesQueryPostRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309OrdersOrderIdShippingServicesQueryPost(ctx context.Context, orderId string) ApiFulfillment202309OrdersOrderIdShippingServicesQueryPostRequest {
    return ApiFulfillment202309OrdersOrderIdShippingServicesQueryPostRequest{
        ApiService: a,
        ctx: ctx,
        orderId: orderId,
    }
}

// Execute executes the request
//  @return Fulfillment202309GetEligibleShippingServiceResponse
func (a *FulfillmentV202309APIService) Fulfillment202309OrdersOrderIdShippingServicesQueryPostExecute(r ApiFulfillment202309OrdersOrderIdShippingServicesQueryPostRequest) (*fulfillment_v202309.Fulfillment202309GetEligibleShippingServiceResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309GetEligibleShippingServiceResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309OrdersOrderIdShippingServicesQueryPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/orders/{order_id}/shipping_services/query"
    localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.fulfillment202309GetEligibleShippingServiceRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309OrdersOrderIdSplitPostRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    orderId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    fulfillment202309SplitOrdersRequestBody *fulfillment_v202309.Fulfillment202309SplitOrdersRequestBody
}

// 
func (r ApiFulfillment202309OrdersOrderIdSplitPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309OrdersOrderIdSplitPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFulfillment202309OrdersOrderIdSplitPostRequest) ContentType(contentType string) ApiFulfillment202309OrdersOrderIdSplitPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFulfillment202309OrdersOrderIdSplitPostRequest) ShopCipher(shopCipher string) ApiFulfillment202309OrdersOrderIdSplitPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFulfillment202309OrdersOrderIdSplitPostRequest) Fulfillment202309SplitOrdersRequestBody(fulfillment202309SplitOrdersRequestBody fulfillment_v202309.Fulfillment202309SplitOrdersRequestBody) ApiFulfillment202309OrdersOrderIdSplitPostRequest {
    r.fulfillment202309SplitOrdersRequestBody = &fulfillment202309SplitOrdersRequestBody
    return r
}
func (r ApiFulfillment202309OrdersOrderIdSplitPostRequest) Execute() (*fulfillment_v202309.Fulfillment202309SplitOrdersResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309OrdersOrderIdSplitPostExecute(r)
}

/*
Fulfillment202309OrdersOrderIdSplitPost SplitOrders
Use this API to confirm an order split. Note that â€‹â€‹supported split levels vary by regionâ€‹â€‹:
- Some regions support â€‹â€‹item-level splitsâ€‹â€‹ (splitting individual units of the same SKU).
- Others only support â€‹â€‹all-units splitsâ€‹â€‹ (splitting different SKUs into separate packages).

Here are two examples of supported splits:
- â€‹â€‹**Case 1**: all-units splitâ€‹â€‹, applicable for orders in BR, SEA, MX (local sellers)
Split a buyer order of SKU A of quantity 2 and SKU B of quantity 1 into two separate packages:
  - â€‹â€‹Package 1â€‹â€‹: all units of SKU A
â€‹â€‹  - Package 2â€‹â€‹: all units of SKU B

- **â€‹â€‹Case 2**: item-level splitâ€‹â€‹, applicable for orders in EU, JP, MX (global sellers), UK, US
Split the same order contents into three individual packages:
  - â€‹â€‹Package 1â€‹â€‹: 1 unit of SKU A
â€‹  - â€‹Package 2â€‹â€‹: 1 unit of SKU A
â€‹â€‹  - Package 3â€‹â€‹: 1 unit of SKU B

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param orderId TikTok Shop order ID.
@return ApiFulfillment202309OrdersOrderIdSplitPostRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309OrdersOrderIdSplitPost(ctx context.Context, orderId string) ApiFulfillment202309OrdersOrderIdSplitPostRequest {
    return ApiFulfillment202309OrdersOrderIdSplitPostRequest{
        ApiService: a,
        ctx: ctx,
        orderId: orderId,
    }
}

// Execute executes the request
//  @return Fulfillment202309SplitOrdersResponse
func (a *FulfillmentV202309APIService) Fulfillment202309OrdersOrderIdSplitPostExecute(r ApiFulfillment202309OrdersOrderIdSplitPostRequest) (*fulfillment_v202309.Fulfillment202309SplitOrdersResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309SplitOrdersResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309OrdersOrderIdSplitPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/orders/{order_id}/split"
    localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.fulfillment202309SplitOrdersRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309OrdersOrderIdTrackingGetRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    orderId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiFulfillment202309OrdersOrderIdTrackingGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309OrdersOrderIdTrackingGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFulfillment202309OrdersOrderIdTrackingGetRequest) ContentType(contentType string) ApiFulfillment202309OrdersOrderIdTrackingGetRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFulfillment202309OrdersOrderIdTrackingGetRequest) ShopCipher(shopCipher string) ApiFulfillment202309OrdersOrderIdTrackingGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFulfillment202309OrdersOrderIdTrackingGetRequest) Execute() (*fulfillment_v202309.Fulfillment202309GetTrackingResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309OrdersOrderIdTrackingGetExecute(r)
}

/*
Fulfillment202309OrdersOrderIdTrackingGet GetTracking
This API can use the order number to obtain the corresponding logistics tracking information.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param orderId TikTok Shop order ID.
@return ApiFulfillment202309OrdersOrderIdTrackingGetRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309OrdersOrderIdTrackingGet(ctx context.Context, orderId string) ApiFulfillment202309OrdersOrderIdTrackingGetRequest {
    return ApiFulfillment202309OrdersOrderIdTrackingGetRequest{
        ApiService: a,
        ctx: ctx,
        orderId: orderId,
    }
}

// Execute executes the request
//  @return Fulfillment202309GetTrackingResponse
func (a *FulfillmentV202309APIService) Fulfillment202309OrdersOrderIdTrackingGetExecute(r ApiFulfillment202309OrdersOrderIdTrackingGetRequest) (*fulfillment_v202309.Fulfillment202309GetTrackingResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309GetTrackingResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309OrdersOrderIdTrackingGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/orders/{order_id}/tracking"
    localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309OrdersSplitAttributesGetRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    orderIds *[]string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// Query list of TikTok Shop order IDs.
func (r ApiFulfillment202309OrdersSplitAttributesGetRequest) OrderIds(orderIds []string) ApiFulfillment202309OrdersSplitAttributesGetRequest {
    r.orderIds = &orderIds
    return r
}
// 
func (r ApiFulfillment202309OrdersSplitAttributesGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309OrdersSplitAttributesGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFulfillment202309OrdersSplitAttributesGetRequest) ContentType(contentType string) ApiFulfillment202309OrdersSplitAttributesGetRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFulfillment202309OrdersSplitAttributesGetRequest) ShopCipher(shopCipher string) ApiFulfillment202309OrdersSplitAttributesGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFulfillment202309OrdersSplitAttributesGetRequest) Execute() (*fulfillment_v202309.Fulfillment202309GetOrderSplitAttributesResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309OrdersSplitAttributesGetExecute(r)
}

/*
Fulfillment202309OrdersSplitAttributesGet GetOrderSplitAttributes
Use this API to check whether an order(s) can be split into multiple packages or not.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiFulfillment202309OrdersSplitAttributesGetRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309OrdersSplitAttributesGet(ctx context.Context) ApiFulfillment202309OrdersSplitAttributesGetRequest {
    return ApiFulfillment202309OrdersSplitAttributesGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Fulfillment202309GetOrderSplitAttributesResponse
func (a *FulfillmentV202309APIService) Fulfillment202309OrdersSplitAttributesGetExecute(r ApiFulfillment202309OrdersSplitAttributesGetRequest) (*fulfillment_v202309.Fulfillment202309GetOrderSplitAttributesResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309GetOrderSplitAttributesResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309OrdersSplitAttributesGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/orders/split_attributes"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.orderIds == nil {
        return localVarReturnValue, nil, reportError("orderIds is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    {
        t := *r.orderIds
        if reflect.TypeOf(t).Kind() == reflect.Slice {
            s := reflect.ValueOf(t)
            for i := 0; i < s.Len(); i++ {
                parameterAddToHeaderOrQuery(localVarQueryParams, "order_ids", s.Index(i).Interface(), "multi")
            }
        } else {
            parameterAddToHeaderOrQuery(localVarQueryParams, "order_ids", t, "multi")
        }
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309PackagesCombinePostRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    fulfillment202309CombinePackageRequestBody *fulfillment_v202309.Fulfillment202309CombinePackageRequestBody
}

// 
func (r ApiFulfillment202309PackagesCombinePostRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309PackagesCombinePostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFulfillment202309PackagesCombinePostRequest) ContentType(contentType string) ApiFulfillment202309PackagesCombinePostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFulfillment202309PackagesCombinePostRequest) ShopCipher(shopCipher string) ApiFulfillment202309PackagesCombinePostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFulfillment202309PackagesCombinePostRequest) Fulfillment202309CombinePackageRequestBody(fulfillment202309CombinePackageRequestBody fulfillment_v202309.Fulfillment202309CombinePackageRequestBody) ApiFulfillment202309PackagesCombinePostRequest {
    r.fulfillment202309CombinePackageRequestBody = &fulfillment202309CombinePackageRequestBody
    return r
}
func (r ApiFulfillment202309PackagesCombinePostRequest) Execute() (*fulfillment_v202309.Fulfillment202309CombinePackageResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309PackagesCombinePostExecute(r)
}

/*
Fulfillment202309PackagesCombinePost CombinePackage
Use this API to combine packages into one fulfillment package.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiFulfillment202309PackagesCombinePostRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesCombinePost(ctx context.Context) ApiFulfillment202309PackagesCombinePostRequest {
    return ApiFulfillment202309PackagesCombinePostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Fulfillment202309CombinePackageResponse
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesCombinePostExecute(r ApiFulfillment202309PackagesCombinePostRequest) (*fulfillment_v202309.Fulfillment202309CombinePackageResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309CombinePackageResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309PackagesCombinePost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/packages/combine"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.fulfillment202309CombinePackageRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309PackagesDeliverPostRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    fulfillment202309UpdatePackageDeliveryStatusRequestBody *fulfillment_v202309.Fulfillment202309UpdatePackageDeliveryStatusRequestBody
}

// 
func (r ApiFulfillment202309PackagesDeliverPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309PackagesDeliverPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFulfillment202309PackagesDeliverPostRequest) ContentType(contentType string) ApiFulfillment202309PackagesDeliverPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFulfillment202309PackagesDeliverPostRequest) ShopCipher(shopCipher string) ApiFulfillment202309PackagesDeliverPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFulfillment202309PackagesDeliverPostRequest) Fulfillment202309UpdatePackageDeliveryStatusRequestBody(fulfillment202309UpdatePackageDeliveryStatusRequestBody fulfillment_v202309.Fulfillment202309UpdatePackageDeliveryStatusRequestBody) ApiFulfillment202309PackagesDeliverPostRequest {
    r.fulfillment202309UpdatePackageDeliveryStatusRequestBody = &fulfillment202309UpdatePackageDeliveryStatusRequestBody
    return r
}
func (r ApiFulfillment202309PackagesDeliverPostRequest) Execute() (*fulfillment_v202309.Fulfillment202309UpdatePackageDeliveryStatusResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309PackagesDeliverPostExecute(r)
}

/*
Fulfillment202309PackagesDeliverPost UpdatePackageDeliveryStatus
Use this API to update the delivery status of the package from in transit status. Please note that only sellers utilizing the SOF( Seller Own Fleet) capability can use this API to update the package status to 'DELIVERED'. This API is only available for the SEA region.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiFulfillment202309PackagesDeliverPostRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesDeliverPost(ctx context.Context) ApiFulfillment202309PackagesDeliverPostRequest {
    return ApiFulfillment202309PackagesDeliverPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Fulfillment202309UpdatePackageDeliveryStatusResponse
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesDeliverPostExecute(r ApiFulfillment202309PackagesDeliverPostRequest) (*fulfillment_v202309.Fulfillment202309UpdatePackageDeliveryStatusResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309UpdatePackageDeliveryStatusResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309PackagesDeliverPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/packages/deliver"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.fulfillment202309UpdatePackageDeliveryStatusRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309PackagesPackageIdGetRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    packageId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiFulfillment202309PackagesPackageIdGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309PackagesPackageIdGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFulfillment202309PackagesPackageIdGetRequest) ContentType(contentType string) ApiFulfillment202309PackagesPackageIdGetRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFulfillment202309PackagesPackageIdGetRequest) ShopCipher(shopCipher string) ApiFulfillment202309PackagesPackageIdGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFulfillment202309PackagesPackageIdGetRequest) Execute() (*fulfillment_v202309.Fulfillment202309GetPackageDetailResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309PackagesPackageIdGetExecute(r)
}

/*
Fulfillment202309PackagesPackageIdGet GetPackageDetail
Returns information about a package, including handover time slot, tracking number, and shipping provider information.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param packageId TikTok Shop package ID.
@return ApiFulfillment202309PackagesPackageIdGetRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesPackageIdGet(ctx context.Context, packageId string) ApiFulfillment202309PackagesPackageIdGetRequest {
    return ApiFulfillment202309PackagesPackageIdGetRequest{
        ApiService: a,
        ctx: ctx,
        packageId: packageId,
    }
}

// Execute executes the request
//  @return Fulfillment202309GetPackageDetailResponse
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesPackageIdGetExecute(r ApiFulfillment202309PackagesPackageIdGetRequest) (*fulfillment_v202309.Fulfillment202309GetPackageDetailResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309GetPackageDetailResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309PackagesPackageIdGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/packages/{package_id}"
    localVarPath = strings.Replace(localVarPath, "{"+"package_id"+"}", url.PathEscape(parameterValueToString(r.packageId, "packageId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309PackagesPackageIdHandoverTimeSlotsGetRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    packageId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiFulfillment202309PackagesPackageIdHandoverTimeSlotsGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309PackagesPackageIdHandoverTimeSlotsGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFulfillment202309PackagesPackageIdHandoverTimeSlotsGetRequest) ContentType(contentType string) ApiFulfillment202309PackagesPackageIdHandoverTimeSlotsGetRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFulfillment202309PackagesPackageIdHandoverTimeSlotsGetRequest) ShopCipher(shopCipher string) ApiFulfillment202309PackagesPackageIdHandoverTimeSlotsGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFulfillment202309PackagesPackageIdHandoverTimeSlotsGetRequest) Execute() (*fulfillment_v202309.Fulfillment202309GetPackageHandoverTimeSlotsResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309PackagesPackageIdHandoverTimeSlotsGetExecute(r)
}

/*
Fulfillment202309PackagesPackageIdHandoverTimeSlotsGet GetPackageHandoverTimeSlots
Use this API to retrieve the time slots available for pickup, drop-off, or van collection for the seller's specified package by using package ID.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param packageId TikTok Shop package ID.
@return ApiFulfillment202309PackagesPackageIdHandoverTimeSlotsGetRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesPackageIdHandoverTimeSlotsGet(ctx context.Context, packageId string) ApiFulfillment202309PackagesPackageIdHandoverTimeSlotsGetRequest {
    return ApiFulfillment202309PackagesPackageIdHandoverTimeSlotsGetRequest{
        ApiService: a,
        ctx: ctx,
        packageId: packageId,
    }
}

// Execute executes the request
//  @return Fulfillment202309GetPackageHandoverTimeSlotsResponse
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesPackageIdHandoverTimeSlotsGetExecute(r ApiFulfillment202309PackagesPackageIdHandoverTimeSlotsGetRequest) (*fulfillment_v202309.Fulfillment202309GetPackageHandoverTimeSlotsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309GetPackageHandoverTimeSlotsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309PackagesPackageIdHandoverTimeSlotsGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/packages/{package_id}/handover_time_slots"
    localVarPath = strings.Replace(localVarPath, "{"+"package_id"+"}", url.PathEscape(parameterValueToString(r.packageId, "packageId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309PackagesPackageIdShipPostRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    packageId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    fulfillment202309ShipPackageRequestBody *fulfillment_v202309.Fulfillment202309ShipPackageRequestBody
}

// 
func (r ApiFulfillment202309PackagesPackageIdShipPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309PackagesPackageIdShipPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFulfillment202309PackagesPackageIdShipPostRequest) ContentType(contentType string) ApiFulfillment202309PackagesPackageIdShipPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFulfillment202309PackagesPackageIdShipPostRequest) ShopCipher(shopCipher string) ApiFulfillment202309PackagesPackageIdShipPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFulfillment202309PackagesPackageIdShipPostRequest) Fulfillment202309ShipPackageRequestBody(fulfillment202309ShipPackageRequestBody fulfillment_v202309.Fulfillment202309ShipPackageRequestBody) ApiFulfillment202309PackagesPackageIdShipPostRequest {
    r.fulfillment202309ShipPackageRequestBody = &fulfillment202309ShipPackageRequestBody
    return r
}
func (r ApiFulfillment202309PackagesPackageIdShipPostRequest) Execute() (*fulfillment_v202309.Fulfillment202309ShipPackageResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309PackagesPackageIdShipPostExecute(r)
}

/*
Fulfillment202309PackagesPackageIdShipPost ShipPackage
Use this API to ship a package. There are two kinds of shipping options available: `TikTok Shipping` or `Seller Shipping`.

- `TikTok Shipping`: Schedule a package handover time for TikTok Shipping carriers to pickup a package from seller.
- `Seller Shipping`: Seller arranges their own shipping, and uploads a tracking number and `shipping_provider_id`. Package ID can be obtained from [Get Order Detail](https://partner.tiktokshop.com/docv2/page/650aa8ccc16ffe02b8f167a0?external_id=650aa8ccc16ffe02b8f167a0#Back%20To%20Top).

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param packageId TikTok Shop package ID.
@return ApiFulfillment202309PackagesPackageIdShipPostRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesPackageIdShipPost(ctx context.Context, packageId string) ApiFulfillment202309PackagesPackageIdShipPostRequest {
    return ApiFulfillment202309PackagesPackageIdShipPostRequest{
        ApiService: a,
        ctx: ctx,
        packageId: packageId,
    }
}

// Execute executes the request
//  @return Fulfillment202309ShipPackageResponse
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesPackageIdShipPostExecute(r ApiFulfillment202309PackagesPackageIdShipPostRequest) (*fulfillment_v202309.Fulfillment202309ShipPackageResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309ShipPackageResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309PackagesPackageIdShipPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/packages/{package_id}/ship"
    localVarPath = strings.Replace(localVarPath, "{"+"package_id"+"}", url.PathEscape(parameterValueToString(r.packageId, "packageId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.fulfillment202309ShipPackageRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309PackagesPackageIdShippingDocumentsGetRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    packageId string
    documentType *string
    xTtsAccessToken *string
    contentType *string
    documentSize *string
    documentFormat *string
    shopCipher *string
}

// Available document types:  - &#x60;SHIPPING_LABEL&#x60;: Returns the shipping label in PDF format by default. - &#x60;PACKING_SLIP&#x60;: Returns the packing slip in PDF format by default. - &#x60;SHIPPING_LABEL_AND_PACKING_SLIP&#x60;: Returns both the shipping label and the packing slip for the package, both in PDF format by default.               - &#x60;SHIPPING_LABEL_PICTURE&#x60;: Returns the shipping label in PNG format.  - &#x60;HAZMAT_LABEL&#x60;: Returns the hazmat label in PDF format by default. You must only use this value when there are hazmat items in the package. When you use the value, &#x60;document_size&#x60; is fixed to A4, and you don&#39;t need to specify &#x60;document_size&#x60;. - &#x60;INVOICE_LABEL&#x60;: For Brazil market only, document_size is fixed to A6, and you don&#39;t need to specify &#x60;document_size&#x60;. Returns the invoice label in PDF format by default
func (r ApiFulfillment202309PackagesPackageIdShippingDocumentsGetRequest) DocumentType(documentType string) ApiFulfillment202309PackagesPackageIdShippingDocumentsGetRequest {
    r.documentType = &documentType
    return r
}
// 
func (r ApiFulfillment202309PackagesPackageIdShippingDocumentsGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309PackagesPackageIdShippingDocumentsGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFulfillment202309PackagesPackageIdShippingDocumentsGetRequest) ContentType(contentType string) ApiFulfillment202309PackagesPackageIdShippingDocumentsGetRequest {
    r.contentType = &contentType
    return r
}
// Use this field to specify the size of the document to obtain. This parameter is only applicable to shipping labels, picking slips, and packing slips that are in the PDF format. It is not applicable for hazmat labels as these are fixed to A4.  If you specify &#x60;SHIPPING_LABEL_PICTURE&#x60; for the &#x60;document_type&#x60;, any value specified in the &#x60;document_size&#x60; will be ignored.   Possible values:  - &#x60;A6&#x60; (Default) - &#x60;A5&#x60; 
func (r ApiFulfillment202309PackagesPackageIdShippingDocumentsGetRequest) DocumentSize(documentSize string) ApiFulfillment202309PackagesPackageIdShippingDocumentsGetRequest {
    r.documentSize = &documentSize
    return r
}
// The format of the shipping document. Possible values:  - PDF (Default) - ZPL (Only for BR market)  **Note**: Not applicable for &#x60;SHIPPING_LABEL_PICTURE&#x60; document type.
func (r ApiFulfillment202309PackagesPackageIdShippingDocumentsGetRequest) DocumentFormat(documentFormat string) ApiFulfillment202309PackagesPackageIdShippingDocumentsGetRequest {
    r.documentFormat = &documentFormat
    return r
}
// 
func (r ApiFulfillment202309PackagesPackageIdShippingDocumentsGetRequest) ShopCipher(shopCipher string) ApiFulfillment202309PackagesPackageIdShippingDocumentsGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFulfillment202309PackagesPackageIdShippingDocumentsGetRequest) Execute() (*fulfillment_v202309.Fulfillment202309GetPackageShippingDocumentResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309PackagesPackageIdShippingDocumentsGetExecute(r)
}

/*
Fulfillment202309PackagesPackageIdShippingDocumentsGet GetPackageShippingDocument
For orders shipped by TikTok Shop, this API retrieves the URL of shipping documents (shipping label and packing slip) for a package specified by the package ID. This API is only applicable to "TikTok Shipping" orders. To obtain the shipping documents URL via this API, first call "Ship Package" to ship the corresponding package.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param packageId TikTok Shop package ID. 
@return ApiFulfillment202309PackagesPackageIdShippingDocumentsGetRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesPackageIdShippingDocumentsGet(ctx context.Context, packageId string) ApiFulfillment202309PackagesPackageIdShippingDocumentsGetRequest {
    return ApiFulfillment202309PackagesPackageIdShippingDocumentsGetRequest{
        ApiService: a,
        ctx: ctx,
        packageId: packageId,
    }
}

// Execute executes the request
//  @return Fulfillment202309GetPackageShippingDocumentResponse
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesPackageIdShippingDocumentsGetExecute(r ApiFulfillment202309PackagesPackageIdShippingDocumentsGetRequest) (*fulfillment_v202309.Fulfillment202309GetPackageShippingDocumentResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309GetPackageShippingDocumentResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309PackagesPackageIdShippingDocumentsGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/packages/{package_id}/shipping_documents"
    localVarPath = strings.Replace(localVarPath, "{"+"package_id"+"}", url.PathEscape(parameterValueToString(r.packageId, "packageId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.documentType == nil {
        return localVarReturnValue, nil, reportError("documentType is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    parameterAddToHeaderOrQuery(localVarQueryParams, "document_type", r.documentType, "")
    if r.documentSize != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "document_size", r.documentSize, "")
    }
    if r.documentFormat != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "document_format", r.documentFormat, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309PackagesPackageIdShippingInfoUpdatePostRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    packageId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    fulfillment202309UpdatePackageShippingInfoRequestBody *fulfillment_v202309.Fulfillment202309UpdatePackageShippingInfoRequestBody
}

// 
func (r ApiFulfillment202309PackagesPackageIdShippingInfoUpdatePostRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309PackagesPackageIdShippingInfoUpdatePostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFulfillment202309PackagesPackageIdShippingInfoUpdatePostRequest) ContentType(contentType string) ApiFulfillment202309PackagesPackageIdShippingInfoUpdatePostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFulfillment202309PackagesPackageIdShippingInfoUpdatePostRequest) ShopCipher(shopCipher string) ApiFulfillment202309PackagesPackageIdShippingInfoUpdatePostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFulfillment202309PackagesPackageIdShippingInfoUpdatePostRequest) Fulfillment202309UpdatePackageShippingInfoRequestBody(fulfillment202309UpdatePackageShippingInfoRequestBody fulfillment_v202309.Fulfillment202309UpdatePackageShippingInfoRequestBody) ApiFulfillment202309PackagesPackageIdShippingInfoUpdatePostRequest {
    r.fulfillment202309UpdatePackageShippingInfoRequestBody = &fulfillment202309UpdatePackageShippingInfoRequestBody
    return r
}
func (r ApiFulfillment202309PackagesPackageIdShippingInfoUpdatePostRequest) Execute() (*fulfillment_v202309.Fulfillment202309UpdatePackageShippingInfoResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309PackagesPackageIdShippingInfoUpdatePostExecute(r)
}

/*
Fulfillment202309PackagesPackageIdShippingInfoUpdatePost UpdatePackageShippingInfo
If the seller entered an incorrect tracking number, this API allows the seller to update the tracking number and shipping provider for a package that has already been shipped. Attention: This API is only applicable to orders (or packages) shipped by the seller.  It is only used to update the tracking number and shipping provider for packages that have already been shipped.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param packageId TikTok Shop package ID.
@return ApiFulfillment202309PackagesPackageIdShippingInfoUpdatePostRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesPackageIdShippingInfoUpdatePost(ctx context.Context, packageId string) ApiFulfillment202309PackagesPackageIdShippingInfoUpdatePostRequest {
    return ApiFulfillment202309PackagesPackageIdShippingInfoUpdatePostRequest{
        ApiService: a,
        ctx: ctx,
        packageId: packageId,
    }
}

// Execute executes the request
//  @return Fulfillment202309UpdatePackageShippingInfoResponse
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesPackageIdShippingInfoUpdatePostExecute(r ApiFulfillment202309PackagesPackageIdShippingInfoUpdatePostRequest) (*fulfillment_v202309.Fulfillment202309UpdatePackageShippingInfoResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309UpdatePackageShippingInfoResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309PackagesPackageIdShippingInfoUpdatePost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/packages/{package_id}/shipping_info/update"
    localVarPath = strings.Replace(localVarPath, "{"+"package_id"+"}", url.PathEscape(parameterValueToString(r.packageId, "packageId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.fulfillment202309UpdatePackageShippingInfoRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309PackagesPackageIdUncombinePostRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    packageId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    fulfillment202309UncombinePackagesRequestBody *fulfillment_v202309.Fulfillment202309UncombinePackagesRequestBody
}

// 
func (r ApiFulfillment202309PackagesPackageIdUncombinePostRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309PackagesPackageIdUncombinePostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFulfillment202309PackagesPackageIdUncombinePostRequest) ContentType(contentType string) ApiFulfillment202309PackagesPackageIdUncombinePostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFulfillment202309PackagesPackageIdUncombinePostRequest) ShopCipher(shopCipher string) ApiFulfillment202309PackagesPackageIdUncombinePostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFulfillment202309PackagesPackageIdUncombinePostRequest) Fulfillment202309UncombinePackagesRequestBody(fulfillment202309UncombinePackagesRequestBody fulfillment_v202309.Fulfillment202309UncombinePackagesRequestBody) ApiFulfillment202309PackagesPackageIdUncombinePostRequest {
    r.fulfillment202309UncombinePackagesRequestBody = &fulfillment202309UncombinePackagesRequestBody
    return r
}
func (r ApiFulfillment202309PackagesPackageIdUncombinePostRequest) Execute() (*fulfillment_v202309.Fulfillment202309UncombinePackagesResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309PackagesPackageIdUncombinePostExecute(r)
}

/*
Fulfillment202309PackagesPackageIdUncombinePost UncombinePackages
Use this API to uncombine one or more orders from an already combined package.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param packageId Package ID you wish to uncombine an order(s) from.
@return ApiFulfillment202309PackagesPackageIdUncombinePostRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesPackageIdUncombinePost(ctx context.Context, packageId string) ApiFulfillment202309PackagesPackageIdUncombinePostRequest {
    return ApiFulfillment202309PackagesPackageIdUncombinePostRequest{
        ApiService: a,
        ctx: ctx,
        packageId: packageId,
    }
}

// Execute executes the request
//  @return Fulfillment202309UncombinePackagesResponse
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesPackageIdUncombinePostExecute(r ApiFulfillment202309PackagesPackageIdUncombinePostRequest) (*fulfillment_v202309.Fulfillment202309UncombinePackagesResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309UncombinePackagesResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309PackagesPackageIdUncombinePost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/packages/{package_id}/uncombine"
    localVarPath = strings.Replace(localVarPath, "{"+"package_id"+"}", url.PathEscape(parameterValueToString(r.packageId, "packageId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.fulfillment202309UncombinePackagesRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309PackagesPostRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    fulfillment202309CreatePackagesRequestBody *fulfillment_v202309.Fulfillment202309CreatePackagesRequestBody
}

// 
func (r ApiFulfillment202309PackagesPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309PackagesPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFulfillment202309PackagesPostRequest) ContentType(contentType string) ApiFulfillment202309PackagesPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFulfillment202309PackagesPostRequest) ShopCipher(shopCipher string) ApiFulfillment202309PackagesPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFulfillment202309PackagesPostRequest) Fulfillment202309CreatePackagesRequestBody(fulfillment202309CreatePackagesRequestBody fulfillment_v202309.Fulfillment202309CreatePackagesRequestBody) ApiFulfillment202309PackagesPostRequest {
    r.fulfillment202309CreatePackagesRequestBody = &fulfillment202309CreatePackagesRequestBody
    return r
}
func (r ApiFulfillment202309PackagesPostRequest) Execute() (*fulfillment_v202309.Fulfillment202309CreatePackagesResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309PackagesPostExecute(r)
}

/*
Fulfillment202309PackagesPost CreatePackages
Use this API to ship orders (purchase labels). This API is region specific to the US. The shipping fee and delivery time is an estimate only and is based on the package dimensions and weight you provided. Based on the package attributes, options listed below may differ from your shipping subscriptions.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiFulfillment202309PackagesPostRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesPost(ctx context.Context) ApiFulfillment202309PackagesPostRequest {
    return ApiFulfillment202309PackagesPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Fulfillment202309CreatePackagesResponse
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesPostExecute(r ApiFulfillment202309PackagesPostRequest) (*fulfillment_v202309.Fulfillment202309CreatePackagesResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309CreatePackagesResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309PackagesPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/packages"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.fulfillment202309CreatePackagesRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309PackagesSchedulePostRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    fulfillment202309SchedulePackageHandoverRequestBody *fulfillment_v202309.Fulfillment202309SchedulePackageHandoverRequestBody
}

// 
func (r ApiFulfillment202309PackagesSchedulePostRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309PackagesSchedulePostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFulfillment202309PackagesSchedulePostRequest) ContentType(contentType string) ApiFulfillment202309PackagesSchedulePostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFulfillment202309PackagesSchedulePostRequest) ShopCipher(shopCipher string) ApiFulfillment202309PackagesSchedulePostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFulfillment202309PackagesSchedulePostRequest) Fulfillment202309SchedulePackageHandoverRequestBody(fulfillment202309SchedulePackageHandoverRequestBody fulfillment_v202309.Fulfillment202309SchedulePackageHandoverRequestBody) ApiFulfillment202309PackagesSchedulePostRequest {
    r.fulfillment202309SchedulePackageHandoverRequestBody = &fulfillment202309SchedulePackageHandoverRequestBody
    return r
}
func (r ApiFulfillment202309PackagesSchedulePostRequest) Execute() (*fulfillment_v202309.Fulfillment202309SchedulePackageHandoverResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309PackagesSchedulePostExecute(r)
}

/*
Fulfillment202309PackagesSchedulePost SchedulePackageHandover
Use this API to schedule a platform shipping package pickup or drop off. After scheduling the package pickup or drop off, the API will return relevant package pickup/ drop off info.  Note: Please use order id to schedule a package pickup or drop off.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiFulfillment202309PackagesSchedulePostRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesSchedulePost(ctx context.Context) ApiFulfillment202309PackagesSchedulePostRequest {
    return ApiFulfillment202309PackagesSchedulePostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Fulfillment202309SchedulePackageHandoverResponse
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesSchedulePostExecute(r ApiFulfillment202309PackagesSchedulePostRequest) (*fulfillment_v202309.Fulfillment202309SchedulePackageHandoverResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309SchedulePackageHandoverResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309PackagesSchedulePost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/packages/schedule"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.fulfillment202309SchedulePackageHandoverRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309PackagesSearchPostRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    pageSize *int32
    xTtsAccessToken *string
    contentType *string
    sortField *string
    sortOrder *string
    pageToken *string
    shopCipher *string
    fulfillment202309SearchPackageRequestBody *fulfillment_v202309.Fulfillment202309SearchPackageRequestBody
}

// The number of results to be returned per page. Valid range: [1-50].
func (r ApiFulfillment202309PackagesSearchPostRequest) PageSize(pageSize int32) ApiFulfillment202309PackagesSearchPostRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiFulfillment202309PackagesSearchPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309PackagesSearchPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFulfillment202309PackagesSearchPostRequest) ContentType(contentType string) ApiFulfillment202309PackagesSearchPostRequest {
    r.contentType = &contentType
    return r
}
// The returned results will be sorted by the specified field.  Default: &#x60;create_time&#x60; Possible values: - &#x60;create_time&#x60; - &#x60;update_time&#x60; - &#x60;order_pay_time&#x60;  Specify the order for sorting the returned results by using the sort_order parameter.
func (r ApiFulfillment202309PackagesSearchPostRequest) SortField(sortField string) ApiFulfillment202309PackagesSearchPostRequest {
    r.sortField = &sortField
    return r
}
// The sort order for the sort_field parameter. Default: &#x60;DESC&#x60; Possible values: - &#x60;ASC&#x60;: Ascending order - &#x60;DESC&#x60;: Descending order
func (r ApiFulfillment202309PackagesSearchPostRequest) SortOrder(sortOrder string) ApiFulfillment202309PackagesSearchPostRequest {
    r.sortOrder = &sortOrder
    return r
}
// An opaque token used to retrieve the next page of a paginated result set. Retrieve this value from the result of the &#x60;next_page_token&#x60; from a previous response. It is not needed for the first page.
func (r ApiFulfillment202309PackagesSearchPostRequest) PageToken(pageToken string) ApiFulfillment202309PackagesSearchPostRequest {
    r.pageToken = &pageToken
    return r
}
// 
func (r ApiFulfillment202309PackagesSearchPostRequest) ShopCipher(shopCipher string) ApiFulfillment202309PackagesSearchPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFulfillment202309PackagesSearchPostRequest) Fulfillment202309SearchPackageRequestBody(fulfillment202309SearchPackageRequestBody fulfillment_v202309.Fulfillment202309SearchPackageRequestBody) ApiFulfillment202309PackagesSearchPostRequest {
    r.fulfillment202309SearchPackageRequestBody = &fulfillment202309SearchPackageRequestBody
    return r
}
func (r ApiFulfillment202309PackagesSearchPostRequest) Execute() (*fulfillment_v202309.Fulfillment202309SearchPackageResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309PackagesSearchPostExecute(r)
}

/*
Fulfillment202309PackagesSearchPost SearchPackage
Retrieve package IDs based on specified conditions. Package creation time and information update time are the common querying conditions.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiFulfillment202309PackagesSearchPostRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesSearchPost(ctx context.Context) ApiFulfillment202309PackagesSearchPostRequest {
    return ApiFulfillment202309PackagesSearchPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Fulfillment202309SearchPackageResponse
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesSearchPostExecute(r ApiFulfillment202309PackagesSearchPostRequest) (*fulfillment_v202309.Fulfillment202309SearchPackageResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309SearchPackageResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309PackagesSearchPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/packages/search"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.pageSize == nil {
        return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    if r.sortField != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "sort_field", r.sortField, "")
    }
    if r.sortOrder != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "")
    }
    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.fulfillment202309SearchPackageRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFulfillment202309PackagesShipPostRequest struct {
    ctx context.Context
    ApiService *FulfillmentV202309APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    fulfillment202309BatchShipPackagesRequestBody *fulfillment_v202309.Fulfillment202309BatchShipPackagesRequestBody
}

// 
func (r ApiFulfillment202309PackagesShipPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiFulfillment202309PackagesShipPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFulfillment202309PackagesShipPostRequest) ContentType(contentType string) ApiFulfillment202309PackagesShipPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFulfillment202309PackagesShipPostRequest) ShopCipher(shopCipher string) ApiFulfillment202309PackagesShipPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFulfillment202309PackagesShipPostRequest) Fulfillment202309BatchShipPackagesRequestBody(fulfillment202309BatchShipPackagesRequestBody fulfillment_v202309.Fulfillment202309BatchShipPackagesRequestBody) ApiFulfillment202309PackagesShipPostRequest {
    r.fulfillment202309BatchShipPackagesRequestBody = &fulfillment202309BatchShipPackagesRequestBody
    return r
}
func (r ApiFulfillment202309PackagesShipPostRequest) Execute() (*fulfillment_v202309.Fulfillment202309BatchShipPackagesResponse, *http.Response, error) {
    return r.ApiService.Fulfillment202309PackagesShipPostExecute(r)
}

/*
Fulfillment202309PackagesShipPost BatchShipPackages
Use this API to batch ship packages by providing multiple package IDs. This API is available for TikTok shipping orders as well as seller shipping orders. 

- `TikTok Shipping`: Schedule a package handover time for TikTok Shipping carriers to pickup a package from the Seller. 
- `Seller Shipping`: Seller arranges their own shipping, and upload a `tracking_number` and `shipping_provider_id`. Package ID can be obtained from [Get Order Detail](https://partner.tiktokshop.com/docv2/page/650aa8ccc16ffe02b8f167a0?external_id=650aa8ccc16ffe02b8f167a0).

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiFulfillment202309PackagesShipPostRequest
*/
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesShipPost(ctx context.Context) ApiFulfillment202309PackagesShipPostRequest {
    return ApiFulfillment202309PackagesShipPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Fulfillment202309BatchShipPackagesResponse
func (a *FulfillmentV202309APIService) Fulfillment202309PackagesShipPostExecute(r ApiFulfillment202309PackagesShipPostRequest) (*fulfillment_v202309.Fulfillment202309BatchShipPackagesResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fulfillment_v202309.Fulfillment202309BatchShipPackagesResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentV202309APIService.Fulfillment202309PackagesShipPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fulfillment/202309/packages/ship"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.fulfillment202309BatchShipPackagesRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
