/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"
    "strings"

    "tiktokshop/open/sdk_golang/models/logistics/v202309"
)


// LogisticsV202309APIService LogisticsV202309API service
type LogisticsV202309APIService service

type ApiLogistics202309DeliveryOptionsDeliveryOptionIdShippingProvidersGetRequest struct {
    ctx context.Context
    ApiService *LogisticsV202309APIService
    deliveryOptionId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiLogistics202309DeliveryOptionsDeliveryOptionIdShippingProvidersGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiLogistics202309DeliveryOptionsDeliveryOptionIdShippingProvidersGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiLogistics202309DeliveryOptionsDeliveryOptionIdShippingProvidersGetRequest) ContentType(contentType string) ApiLogistics202309DeliveryOptionsDeliveryOptionIdShippingProvidersGetRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiLogistics202309DeliveryOptionsDeliveryOptionIdShippingProvidersGetRequest) ShopCipher(shopCipher string) ApiLogistics202309DeliveryOptionsDeliveryOptionIdShippingProvidersGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiLogistics202309DeliveryOptionsDeliveryOptionIdShippingProvidersGetRequest) Execute() (*logistics_v202309.Logistics202309GetShippingProvidersResponse, *http.Response, error) {
    return r.ApiService.Logistics202309DeliveryOptionsDeliveryOptionIdShippingProvidersGetExecute(r)
}

/*
Logistics202309DeliveryOptionsDeliveryOptionIdShippingProvidersGet GetShippingProviders
This API is used to obtain the shipping provider corresponding to the specified delivery option

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param deliveryOptionId The specific delivery option identifier for getting the shipping provider list.
@return ApiLogistics202309DeliveryOptionsDeliveryOptionIdShippingProvidersGetRequest
*/
func (a *LogisticsV202309APIService) Logistics202309DeliveryOptionsDeliveryOptionIdShippingProvidersGet(ctx context.Context, deliveryOptionId string) ApiLogistics202309DeliveryOptionsDeliveryOptionIdShippingProvidersGetRequest {
    return ApiLogistics202309DeliveryOptionsDeliveryOptionIdShippingProvidersGetRequest{
        ApiService: a,
        ctx: ctx,
        deliveryOptionId: deliveryOptionId,
    }
}

// Execute executes the request
//  @return Logistics202309GetShippingProvidersResponse
func (a *LogisticsV202309APIService) Logistics202309DeliveryOptionsDeliveryOptionIdShippingProvidersGetExecute(r ApiLogistics202309DeliveryOptionsDeliveryOptionIdShippingProvidersGetRequest) (*logistics_v202309.Logistics202309GetShippingProvidersResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *logistics_v202309.Logistics202309GetShippingProvidersResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogisticsV202309APIService.Logistics202309DeliveryOptionsDeliveryOptionIdShippingProvidersGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/logistics/202309/delivery_options/{delivery_option_id}/shipping_providers"
    localVarPath = strings.Replace(localVarPath, "{"+"delivery_option_id"+"}", url.PathEscape(parameterValueToString(r.deliveryOptionId, "deliveryOptionId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLogistics202309GlobalWarehousesGetRequest struct {
    ctx context.Context
    ApiService *LogisticsV202309APIService
    xTtsAccessToken *string
    contentType *string
}

// 
func (r ApiLogistics202309GlobalWarehousesGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiLogistics202309GlobalWarehousesGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiLogistics202309GlobalWarehousesGetRequest) ContentType(contentType string) ApiLogistics202309GlobalWarehousesGetRequest {
    r.contentType = &contentType
    return r
}
func (r ApiLogistics202309GlobalWarehousesGetRequest) Execute() (*logistics_v202309.Logistics202309GetGlobalSellerWarehouseResponse, *http.Response, error) {
    return r.ApiService.Logistics202309GlobalWarehousesGetExecute(r)
}

/*
Logistics202309GlobalWarehousesGet GetGlobalSellerWarehouse
This API retrieves all global warehouse information associated with the seller. Warehouse information includes global warehouse ID, warehouse name, and warehouse ownership.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiLogistics202309GlobalWarehousesGetRequest
*/
func (a *LogisticsV202309APIService) Logistics202309GlobalWarehousesGet(ctx context.Context) ApiLogistics202309GlobalWarehousesGetRequest {
    return ApiLogistics202309GlobalWarehousesGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Logistics202309GetGlobalSellerWarehouseResponse
func (a *LogisticsV202309APIService) Logistics202309GlobalWarehousesGetExecute(r ApiLogistics202309GlobalWarehousesGetRequest) (*logistics_v202309.Logistics202309GetGlobalSellerWarehouseResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *logistics_v202309.Logistics202309GetGlobalSellerWarehouseResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogisticsV202309APIService.Logistics202309GlobalWarehousesGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/logistics/202309/global_warehouses"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLogistics202309WarehousesGetRequest struct {
    ctx context.Context
    ApiService *LogisticsV202309APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiLogistics202309WarehousesGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiLogistics202309WarehousesGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiLogistics202309WarehousesGetRequest) ContentType(contentType string) ApiLogistics202309WarehousesGetRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiLogistics202309WarehousesGetRequest) ShopCipher(shopCipher string) ApiLogistics202309WarehousesGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiLogistics202309WarehousesGetRequest) Execute() (*logistics_v202309.Logistics202309GetWarehouseListResponse, *http.Response, error) {
    return r.ApiService.Logistics202309WarehousesGetExecute(r)
}

/*
Logistics202309WarehousesGet GetWarehouseList
This API retrieves all warehouse information associated with the seller. Warehouse information includes name, status, address, and other details.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiLogistics202309WarehousesGetRequest
*/
func (a *LogisticsV202309APIService) Logistics202309WarehousesGet(ctx context.Context) ApiLogistics202309WarehousesGetRequest {
    return ApiLogistics202309WarehousesGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Logistics202309GetWarehouseListResponse
func (a *LogisticsV202309APIService) Logistics202309WarehousesGetExecute(r ApiLogistics202309WarehousesGetRequest) (*logistics_v202309.Logistics202309GetWarehouseListResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *logistics_v202309.Logistics202309GetWarehouseListResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogisticsV202309APIService.Logistics202309WarehousesGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/logistics/202309/warehouses"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLogistics202309WarehousesWarehouseIdDeliveryOptionsGetRequest struct {
    ctx context.Context
    ApiService *LogisticsV202309APIService
    warehouseId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiLogistics202309WarehousesWarehouseIdDeliveryOptionsGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiLogistics202309WarehousesWarehouseIdDeliveryOptionsGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiLogistics202309WarehousesWarehouseIdDeliveryOptionsGetRequest) ContentType(contentType string) ApiLogistics202309WarehousesWarehouseIdDeliveryOptionsGetRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiLogistics202309WarehousesWarehouseIdDeliveryOptionsGetRequest) ShopCipher(shopCipher string) ApiLogistics202309WarehousesWarehouseIdDeliveryOptionsGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiLogistics202309WarehousesWarehouseIdDeliveryOptionsGetRequest) Execute() (*logistics_v202309.Logistics202309GetWarehouseDeliveryOptionsResponse, *http.Response, error) {
    return r.ApiService.Logistics202309WarehousesWarehouseIdDeliveryOptionsGetExecute(r)
}

/*
Logistics202309WarehousesWarehouseIdDeliveryOptionsGet GetWarehouseDeliveryOptions
This API is used to obtain a list of delivery options available through the seller's designated warehouse.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param warehouseId The warehouse ID.
@return ApiLogistics202309WarehousesWarehouseIdDeliveryOptionsGetRequest
*/
func (a *LogisticsV202309APIService) Logistics202309WarehousesWarehouseIdDeliveryOptionsGet(ctx context.Context, warehouseId string) ApiLogistics202309WarehousesWarehouseIdDeliveryOptionsGetRequest {
    return ApiLogistics202309WarehousesWarehouseIdDeliveryOptionsGetRequest{
        ApiService: a,
        ctx: ctx,
        warehouseId: warehouseId,
    }
}

// Execute executes the request
//  @return Logistics202309GetWarehouseDeliveryOptionsResponse
func (a *LogisticsV202309APIService) Logistics202309WarehousesWarehouseIdDeliveryOptionsGetExecute(r ApiLogistics202309WarehousesWarehouseIdDeliveryOptionsGetRequest) (*logistics_v202309.Logistics202309GetWarehouseDeliveryOptionsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *logistics_v202309.Logistics202309GetWarehouseDeliveryOptionsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogisticsV202309APIService.Logistics202309WarehousesWarehouseIdDeliveryOptionsGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/logistics/202309/warehouses/{warehouse_id}/delivery_options"
    localVarPath = strings.Replace(localVarPath, "{"+"warehouse_id"+"}", url.PathEscape(parameterValueToString(r.warehouseId, "warehouseId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
