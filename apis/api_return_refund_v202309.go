/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"
    "strings"

    "tiktokshop/open/sdk_golang/models/return_refund/v202309"
)


// ReturnRefundV202309APIService ReturnRefundV202309API service
type ReturnRefundV202309APIService service

type ApiReturnRefund202309CancellationsCancelIdApprovePostRequest struct {
    ctx context.Context
    ApiService *ReturnRefundV202309APIService
    cancelId string
    xTtsAccessToken *string
    contentType *string
    idempotencyKey *string
    shopCipher *string
}

// 
func (r ApiReturnRefund202309CancellationsCancelIdApprovePostRequest) XTtsAccessToken(xTtsAccessToken string) ApiReturnRefund202309CancellationsCancelIdApprovePostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiReturnRefund202309CancellationsCancelIdApprovePostRequest) ContentType(contentType string) ApiReturnRefund202309CancellationsCancelIdApprovePostRequest {
    r.contentType = &contentType
    return r
}
// The idempotency key is a unique value generated by the client which the server uses to recognize a request.   You may choose your own method of creating unique keys. We suggest using UUIDs, or another random string with enough entropy, to avoid collisions.   Idempotency keys can be up to 255 characters long.
func (r ApiReturnRefund202309CancellationsCancelIdApprovePostRequest) IdempotencyKey(idempotencyKey string) ApiReturnRefund202309CancellationsCancelIdApprovePostRequest {
    r.idempotencyKey = &idempotencyKey
    return r
}
// 
func (r ApiReturnRefund202309CancellationsCancelIdApprovePostRequest) ShopCipher(shopCipher string) ApiReturnRefund202309CancellationsCancelIdApprovePostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiReturnRefund202309CancellationsCancelIdApprovePostRequest) Execute() (*return_refund_v202309.ReturnRefund202309ApproveCancellationResponse, *http.Response, error) {
    return r.ApiService.ReturnRefund202309CancellationsCancelIdApprovePostExecute(r)
}

/*
ReturnRefund202309CancellationsCancelIdApprovePost ApproveCancellation
Use this API to approve a buyer's order cancellation request.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param cancelId The identifier of a specific cancellation request.
@return ApiReturnRefund202309CancellationsCancelIdApprovePostRequest
*/
func (a *ReturnRefundV202309APIService) ReturnRefund202309CancellationsCancelIdApprovePost(ctx context.Context, cancelId string) ApiReturnRefund202309CancellationsCancelIdApprovePostRequest {
    return ApiReturnRefund202309CancellationsCancelIdApprovePostRequest{
        ApiService: a,
        ctx: ctx,
        cancelId: cancelId,
    }
}

// Execute executes the request
//  @return ReturnRefund202309ApproveCancellationResponse
func (a *ReturnRefundV202309APIService) ReturnRefund202309CancellationsCancelIdApprovePostExecute(r ApiReturnRefund202309CancellationsCancelIdApprovePostRequest) (*return_refund_v202309.ReturnRefund202309ApproveCancellationResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *return_refund_v202309.ReturnRefund202309ApproveCancellationResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReturnRefundV202309APIService.ReturnRefund202309CancellationsCancelIdApprovePost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/return_refund/202309/cancellations/{cancel_id}/approve"
    localVarPath = strings.Replace(localVarPath, "{"+"cancel_id"+"}", url.PathEscape(parameterValueToString(r.cancelId, "cancelId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.idempotencyKey != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "idempotency_key", r.idempotencyKey, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReturnRefund202309CancellationsCancelIdRejectPostRequest struct {
    ctx context.Context
    ApiService *ReturnRefundV202309APIService
    cancelId string
    xTtsAccessToken *string
    contentType *string
    idempotencyKey *string
    shopCipher *string
    returnRefund202309RejectCancellationRequestBody *return_refund_v202309.ReturnRefund202309RejectCancellationRequestBody
}

// 
func (r ApiReturnRefund202309CancellationsCancelIdRejectPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiReturnRefund202309CancellationsCancelIdRejectPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiReturnRefund202309CancellationsCancelIdRejectPostRequest) ContentType(contentType string) ApiReturnRefund202309CancellationsCancelIdRejectPostRequest {
    r.contentType = &contentType
    return r
}
// The idempotency key is a unique value generated by the client which the server uses to recognize a request.   You may choose your own method of creating unique keys. We suggest using UUIDs, or another random string with enough entropy, to avoid collisions.   Idempotency keys can be up to 255 characters long.
func (r ApiReturnRefund202309CancellationsCancelIdRejectPostRequest) IdempotencyKey(idempotencyKey string) ApiReturnRefund202309CancellationsCancelIdRejectPostRequest {
    r.idempotencyKey = &idempotencyKey
    return r
}
// 
func (r ApiReturnRefund202309CancellationsCancelIdRejectPostRequest) ShopCipher(shopCipher string) ApiReturnRefund202309CancellationsCancelIdRejectPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiReturnRefund202309CancellationsCancelIdRejectPostRequest) ReturnRefund202309RejectCancellationRequestBody(returnRefund202309RejectCancellationRequestBody return_refund_v202309.ReturnRefund202309RejectCancellationRequestBody) ApiReturnRefund202309CancellationsCancelIdRejectPostRequest {
    r.returnRefund202309RejectCancellationRequestBody = &returnRefund202309RejectCancellationRequestBody
    return r
}
func (r ApiReturnRefund202309CancellationsCancelIdRejectPostRequest) Execute() (*return_refund_v202309.ReturnRefund202309RejectCancellationResponse, *http.Response, error) {
    return r.ApiService.ReturnRefund202309CancellationsCancelIdRejectPostExecute(r)
}

/*
ReturnRefund202309CancellationsCancelIdRejectPost RejectCancellation
Use this API to reject a buyer's order cancellation request.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param cancelId The identifier of a specific cancellation request.
@return ApiReturnRefund202309CancellationsCancelIdRejectPostRequest
*/
func (a *ReturnRefundV202309APIService) ReturnRefund202309CancellationsCancelIdRejectPost(ctx context.Context, cancelId string) ApiReturnRefund202309CancellationsCancelIdRejectPostRequest {
    return ApiReturnRefund202309CancellationsCancelIdRejectPostRequest{
        ApiService: a,
        ctx: ctx,
        cancelId: cancelId,
    }
}

// Execute executes the request
//  @return ReturnRefund202309RejectCancellationResponse
func (a *ReturnRefundV202309APIService) ReturnRefund202309CancellationsCancelIdRejectPostExecute(r ApiReturnRefund202309CancellationsCancelIdRejectPostRequest) (*return_refund_v202309.ReturnRefund202309RejectCancellationResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *return_refund_v202309.ReturnRefund202309RejectCancellationResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReturnRefundV202309APIService.ReturnRefund202309CancellationsCancelIdRejectPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/return_refund/202309/cancellations/{cancel_id}/reject"
    localVarPath = strings.Replace(localVarPath, "{"+"cancel_id"+"}", url.PathEscape(parameterValueToString(r.cancelId, "cancelId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.idempotencyKey != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "idempotency_key", r.idempotencyKey, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.returnRefund202309RejectCancellationRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReturnRefund202309CancellationsPostRequest struct {
    ctx context.Context
    ApiService *ReturnRefundV202309APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    returnRefund202309CancelOrderRequestBody *return_refund_v202309.ReturnRefund202309CancelOrderRequestBody
}

// 
func (r ApiReturnRefund202309CancellationsPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiReturnRefund202309CancellationsPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiReturnRefund202309CancellationsPostRequest) ContentType(contentType string) ApiReturnRefund202309CancellationsPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiReturnRefund202309CancellationsPostRequest) ShopCipher(shopCipher string) ApiReturnRefund202309CancellationsPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiReturnRefund202309CancellationsPostRequest) ReturnRefund202309CancelOrderRequestBody(returnRefund202309CancelOrderRequestBody return_refund_v202309.ReturnRefund202309CancelOrderRequestBody) ApiReturnRefund202309CancellationsPostRequest {
    r.returnRefund202309CancelOrderRequestBody = &returnRefund202309CancelOrderRequestBody
    return r
}
func (r ApiReturnRefund202309CancellationsPostRequest) Execute() (*return_refund_v202309.ReturnRefund202309CancelOrderResponse, *http.Response, error) {
    return r.ApiService.ReturnRefund202309CancellationsPostExecute(r)
}

/*
ReturnRefund202309CancellationsPost CancelOrder
Use this API to cancel an order on behalf of a seller. In the US and UK markets, when an item is out of stock, partial cancellation on the single item level is supported by this API.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiReturnRefund202309CancellationsPostRequest
*/
func (a *ReturnRefundV202309APIService) ReturnRefund202309CancellationsPost(ctx context.Context) ApiReturnRefund202309CancellationsPostRequest {
    return ApiReturnRefund202309CancellationsPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return ReturnRefund202309CancelOrderResponse
func (a *ReturnRefundV202309APIService) ReturnRefund202309CancellationsPostExecute(r ApiReturnRefund202309CancellationsPostRequest) (*return_refund_v202309.ReturnRefund202309CancelOrderResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *return_refund_v202309.ReturnRefund202309CancelOrderResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReturnRefundV202309APIService.ReturnRefund202309CancellationsPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/return_refund/202309/cancellations"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.returnRefund202309CancelOrderRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReturnRefund202309CancellationsSearchPostRequest struct {
    ctx context.Context
    ApiService *ReturnRefundV202309APIService
    xTtsAccessToken *string
    contentType *string
    sortField *string
    sortOrder *string
    pageSize *string
    pageToken *string
    shopCipher *string
    returnRefund202309SearchCancellationsRequestBody *return_refund_v202309.ReturnRefund202309SearchCancellationsRequestBody
}

// 
func (r ApiReturnRefund202309CancellationsSearchPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiReturnRefund202309CancellationsSearchPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiReturnRefund202309CancellationsSearchPostRequest) ContentType(contentType string) ApiReturnRefund202309CancellationsSearchPostRequest {
    r.contentType = &contentType
    return r
}
// The returned results will be sorted by the specified field.  Default: create_time Possible values: - create_time - update_time  Specify the order for sorting the returned results by using the sort_order parameter.
func (r ApiReturnRefund202309CancellationsSearchPostRequest) SortField(sortField string) ApiReturnRefund202309CancellationsSearchPostRequest {
    r.sortField = &sortField
    return r
}
// The sort order for the sort_field parameter.  Default: ASC Possible values: - ASC: Ascending order - DESC: Descending order
func (r ApiReturnRefund202309CancellationsSearchPostRequest) SortOrder(sortOrder string) ApiReturnRefund202309CancellationsSearchPostRequest {
    r.sortOrder = &sortOrder
    return r
}
// The number of results to be returned per page.  Default: 10.  Valid range: [1-50].
func (r ApiReturnRefund202309CancellationsSearchPostRequest) PageSize(pageSize string) ApiReturnRefund202309CancellationsSearchPostRequest {
    r.pageSize = &pageSize
    return r
}
// An opaque token used to retrieve the next page of a paginated result set. Retrieve this value from the result of the next_page_token from a previous response. It is not needed for the first page.
func (r ApiReturnRefund202309CancellationsSearchPostRequest) PageToken(pageToken string) ApiReturnRefund202309CancellationsSearchPostRequest {
    r.pageToken = &pageToken
    return r
}
// 
func (r ApiReturnRefund202309CancellationsSearchPostRequest) ShopCipher(shopCipher string) ApiReturnRefund202309CancellationsSearchPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiReturnRefund202309CancellationsSearchPostRequest) ReturnRefund202309SearchCancellationsRequestBody(returnRefund202309SearchCancellationsRequestBody return_refund_v202309.ReturnRefund202309SearchCancellationsRequestBody) ApiReturnRefund202309CancellationsSearchPostRequest {
    r.returnRefund202309SearchCancellationsRequestBody = &returnRefund202309SearchCancellationsRequestBody
    return r
}
func (r ApiReturnRefund202309CancellationsSearchPostRequest) Execute() (*return_refund_v202309.ReturnRefund202309SearchCancellationsResponse, *http.Response, error) {
    return r.ApiService.ReturnRefund202309CancellationsSearchPostExecute(r)
}

/*
ReturnRefund202309CancellationsSearchPost SearchCancellations
Use this API to search and retrieve one or more order cancellations.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiReturnRefund202309CancellationsSearchPostRequest
*/
func (a *ReturnRefundV202309APIService) ReturnRefund202309CancellationsSearchPost(ctx context.Context) ApiReturnRefund202309CancellationsSearchPostRequest {
    return ApiReturnRefund202309CancellationsSearchPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return ReturnRefund202309SearchCancellationsResponse
func (a *ReturnRefundV202309APIService) ReturnRefund202309CancellationsSearchPostExecute(r ApiReturnRefund202309CancellationsSearchPostRequest) (*return_refund_v202309.ReturnRefund202309SearchCancellationsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *return_refund_v202309.ReturnRefund202309SearchCancellationsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReturnRefundV202309APIService.ReturnRefund202309CancellationsSearchPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/return_refund/202309/cancellations/search"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.sortField != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "sort_field", r.sortField, "")
    }
    if r.sortOrder != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "")
    }
    if r.pageSize != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    }
    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.returnRefund202309SearchCancellationsRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReturnRefund202309OrdersOrderIdAftersaleEligibilityGetRequest struct {
    ctx context.Context
    ApiService *ReturnRefundV202309APIService
    orderId string
    xTtsAccessToken *string
    contentType *string
    initiateAftersaleUser *string
    shopCipher *string
}

// 
func (r ApiReturnRefund202309OrdersOrderIdAftersaleEligibilityGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiReturnRefund202309OrdersOrderIdAftersaleEligibilityGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiReturnRefund202309OrdersOrderIdAftersaleEligibilityGetRequest) ContentType(contentType string) ApiReturnRefund202309OrdersOrderIdAftersaleEligibilityGetRequest {
    r.contentType = &contentType
    return r
}
// The type of user you would like to check aftersale options for. Default: SELLER Possible values: - SELLER - BUYER
func (r ApiReturnRefund202309OrdersOrderIdAftersaleEligibilityGetRequest) InitiateAftersaleUser(initiateAftersaleUser string) ApiReturnRefund202309OrdersOrderIdAftersaleEligibilityGetRequest {
    r.initiateAftersaleUser = &initiateAftersaleUser
    return r
}
// 
func (r ApiReturnRefund202309OrdersOrderIdAftersaleEligibilityGetRequest) ShopCipher(shopCipher string) ApiReturnRefund202309OrdersOrderIdAftersaleEligibilityGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiReturnRefund202309OrdersOrderIdAftersaleEligibilityGetRequest) Execute() (*return_refund_v202309.ReturnRefund202309GetAftersaleEligibilityResponse, *http.Response, error) {
    return r.ApiService.ReturnRefund202309OrdersOrderIdAftersaleEligibilityGetExecute(r)
}

/*
ReturnRefund202309OrdersOrderIdAftersaleEligibilityGet GetAftersaleEligibility
Use this API to check eligible aftersale solutions for an order, including whether the seller or buyer can initiate a refund, return, or cancel a specific order.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param orderId The unique identifier for a TikTok Shop order.
@return ApiReturnRefund202309OrdersOrderIdAftersaleEligibilityGetRequest
*/
func (a *ReturnRefundV202309APIService) ReturnRefund202309OrdersOrderIdAftersaleEligibilityGet(ctx context.Context, orderId string) ApiReturnRefund202309OrdersOrderIdAftersaleEligibilityGetRequest {
    return ApiReturnRefund202309OrdersOrderIdAftersaleEligibilityGetRequest{
        ApiService: a,
        ctx: ctx,
        orderId: orderId,
    }
}

// Execute executes the request
//  @return ReturnRefund202309GetAftersaleEligibilityResponse
func (a *ReturnRefundV202309APIService) ReturnRefund202309OrdersOrderIdAftersaleEligibilityGetExecute(r ApiReturnRefund202309OrdersOrderIdAftersaleEligibilityGetRequest) (*return_refund_v202309.ReturnRefund202309GetAftersaleEligibilityResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *return_refund_v202309.ReturnRefund202309GetAftersaleEligibilityResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReturnRefundV202309APIService.ReturnRefund202309OrdersOrderIdAftersaleEligibilityGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/return_refund/202309/orders/{order_id}/aftersale_eligibility"
    localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.initiateAftersaleUser != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "initiate_aftersale_user", r.initiateAftersaleUser, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReturnRefund202309RefundsCalculatePostRequest struct {
    ctx context.Context
    ApiService *ReturnRefundV202309APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    returnRefund202309CalculateRefundRequestBody *return_refund_v202309.ReturnRefund202309CalculateRefundRequestBody
}

// 
func (r ApiReturnRefund202309RefundsCalculatePostRequest) XTtsAccessToken(xTtsAccessToken string) ApiReturnRefund202309RefundsCalculatePostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiReturnRefund202309RefundsCalculatePostRequest) ContentType(contentType string) ApiReturnRefund202309RefundsCalculatePostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiReturnRefund202309RefundsCalculatePostRequest) ShopCipher(shopCipher string) ApiReturnRefund202309RefundsCalculatePostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiReturnRefund202309RefundsCalculatePostRequest) ReturnRefund202309CalculateRefundRequestBody(returnRefund202309CalculateRefundRequestBody return_refund_v202309.ReturnRefund202309CalculateRefundRequestBody) ApiReturnRefund202309RefundsCalculatePostRequest {
    r.returnRefund202309CalculateRefundRequestBody = &returnRefund202309CalculateRefundRequestBody
    return r
}
func (r ApiReturnRefund202309RefundsCalculatePostRequest) Execute() (*return_refund_v202309.ReturnRefund202309CalculateRefundResponse, *http.Response, error) {
    return r.ApiService.ReturnRefund202309RefundsCalculatePostExecute(r)
}

/*
ReturnRefund202309RefundsCalculatePost CalculateRefund
Use this API to check order refundable amounts.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiReturnRefund202309RefundsCalculatePostRequest
*/
func (a *ReturnRefundV202309APIService) ReturnRefund202309RefundsCalculatePost(ctx context.Context) ApiReturnRefund202309RefundsCalculatePostRequest {
    return ApiReturnRefund202309RefundsCalculatePostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return ReturnRefund202309CalculateRefundResponse
func (a *ReturnRefundV202309APIService) ReturnRefund202309RefundsCalculatePostExecute(r ApiReturnRefund202309RefundsCalculatePostRequest) (*return_refund_v202309.ReturnRefund202309CalculateRefundResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *return_refund_v202309.ReturnRefund202309CalculateRefundResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReturnRefundV202309APIService.ReturnRefund202309RefundsCalculatePost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/return_refund/202309/refunds/calculate"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.returnRefund202309CalculateRefundRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReturnRefund202309RejectReasonsGetRequest struct {
    ctx context.Context
    ApiService *ReturnRefundV202309APIService
    returnOrCancelId *string
    xTtsAccessToken *string
    contentType *string
    locale *string
    shopCipher *string
}

// The unique identifier for an order return or cancellation.
func (r ApiReturnRefund202309RejectReasonsGetRequest) ReturnOrCancelId(returnOrCancelId string) ApiReturnRefund202309RejectReasonsGetRequest {
    r.returnOrCancelId = &returnOrCancelId
    return r
}
// 
func (r ApiReturnRefund202309RejectReasonsGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiReturnRefund202309RejectReasonsGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiReturnRefund202309RejectReasonsGetRequest) ContentType(contentType string) ApiReturnRefund202309RejectReasonsGetRequest {
    r.contentType = &contentType
    return r
}
// The BCP-47 locale codes for displaying the rejection reason, delimited by commas. Default: en-US Refer to [Locale codes](678e3a47bae28f030a8c7523) for the list of supported locale codes.
func (r ApiReturnRefund202309RejectReasonsGetRequest) Locale(locale string) ApiReturnRefund202309RejectReasonsGetRequest {
    r.locale = &locale
    return r
}
// 
func (r ApiReturnRefund202309RejectReasonsGetRequest) ShopCipher(shopCipher string) ApiReturnRefund202309RejectReasonsGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiReturnRefund202309RejectReasonsGetRequest) Execute() (*return_refund_v202309.ReturnRefund202309GetRejectReasonsResponse, *http.Response, error) {
    return r.ApiService.ReturnRefund202309RejectReasonsGetExecute(r)
}

/*
ReturnRefund202309RejectReasonsGet GetRejectReasons
Use this API to obtain order return or cancellation rejection reasons. The seller is required to provide a reason when they reject a cancel, refund, or return request.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiReturnRefund202309RejectReasonsGetRequest
*/
func (a *ReturnRefundV202309APIService) ReturnRefund202309RejectReasonsGet(ctx context.Context) ApiReturnRefund202309RejectReasonsGetRequest {
    return ApiReturnRefund202309RejectReasonsGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return ReturnRefund202309GetRejectReasonsResponse
func (a *ReturnRefundV202309APIService) ReturnRefund202309RejectReasonsGetExecute(r ApiReturnRefund202309RejectReasonsGetRequest) (*return_refund_v202309.ReturnRefund202309GetRejectReasonsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *return_refund_v202309.ReturnRefund202309GetRejectReasonsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReturnRefundV202309APIService.ReturnRefund202309RejectReasonsGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/return_refund/202309/reject_reasons"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.returnOrCancelId == nil {
        return localVarReturnValue, nil, reportError("returnOrCancelId is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.locale != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
    }
    parameterAddToHeaderOrQuery(localVarQueryParams, "return_or_cancel_id", r.returnOrCancelId, "")
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReturnRefund202309ReturnsPostRequest struct {
    ctx context.Context
    ApiService *ReturnRefundV202309APIService
    xTtsAccessToken *string
    contentType *string
    idempotencyKey *string
    shopCipher *string
    returnRefund202309CreateReturnRequestBody *return_refund_v202309.ReturnRefund202309CreateReturnRequestBody
}

// 
func (r ApiReturnRefund202309ReturnsPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiReturnRefund202309ReturnsPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiReturnRefund202309ReturnsPostRequest) ContentType(contentType string) ApiReturnRefund202309ReturnsPostRequest {
    r.contentType = &contentType
    return r
}
// Idempotency Key
func (r ApiReturnRefund202309ReturnsPostRequest) IdempotencyKey(idempotencyKey string) ApiReturnRefund202309ReturnsPostRequest {
    r.idempotencyKey = &idempotencyKey
    return r
}
// 
func (r ApiReturnRefund202309ReturnsPostRequest) ShopCipher(shopCipher string) ApiReturnRefund202309ReturnsPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiReturnRefund202309ReturnsPostRequest) ReturnRefund202309CreateReturnRequestBody(returnRefund202309CreateReturnRequestBody return_refund_v202309.ReturnRefund202309CreateReturnRequestBody) ApiReturnRefund202309ReturnsPostRequest {
    r.returnRefund202309CreateReturnRequestBody = &returnRefund202309CreateReturnRequestBody
    return r
}
func (r ApiReturnRefund202309ReturnsPostRequest) Execute() (*return_refund_v202309.ReturnRefund202309CreateReturnResponse, *http.Response, error) {
    return r.ApiService.ReturnRefund202309ReturnsPostExecute(r)
}

/*
ReturnRefund202309ReturnsPost CreateReturn
Use this API to initiate a return request on behalf of the buyer Sellers can reject the request, or accept and issue: -Return and Refund (buyer must send package back) -Returnless Refund (buyer can keep the item) -Partial Refund (Seller issues a partial refund, buyer can keep the item)

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiReturnRefund202309ReturnsPostRequest
*/
func (a *ReturnRefundV202309APIService) ReturnRefund202309ReturnsPost(ctx context.Context) ApiReturnRefund202309ReturnsPostRequest {
    return ApiReturnRefund202309ReturnsPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return ReturnRefund202309CreateReturnResponse
func (a *ReturnRefundV202309APIService) ReturnRefund202309ReturnsPostExecute(r ApiReturnRefund202309ReturnsPostRequest) (*return_refund_v202309.ReturnRefund202309CreateReturnResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *return_refund_v202309.ReturnRefund202309CreateReturnResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReturnRefundV202309APIService.ReturnRefund202309ReturnsPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/return_refund/202309/returns"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.idempotencyKey != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "idempotency_key", r.idempotencyKey, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.returnRefund202309CreateReturnRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReturnRefund202309ReturnsReturnIdApprovePostRequest struct {
    ctx context.Context
    ApiService *ReturnRefundV202309APIService
    returnId string
    xTtsAccessToken *string
    contentType *string
    idempotencyKey *string
    shopCipher *string
    returnRefund202309ApproveReturnRequestBody *return_refund_v202309.ReturnRefund202309ApproveReturnRequestBody
}

// 
func (r ApiReturnRefund202309ReturnsReturnIdApprovePostRequest) XTtsAccessToken(xTtsAccessToken string) ApiReturnRefund202309ReturnsReturnIdApprovePostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiReturnRefund202309ReturnsReturnIdApprovePostRequest) ContentType(contentType string) ApiReturnRefund202309ReturnsReturnIdApprovePostRequest {
    r.contentType = &contentType
    return r
}
// The idempotency key is a unique value generated by the client which the server uses to recognize the same request. How you create unique keys is up to you, but we suggest using UUIDs, or another random string with enough entropy to avoid collisions. Idempotency keys can be up to 255 characters long.
func (r ApiReturnRefund202309ReturnsReturnIdApprovePostRequest) IdempotencyKey(idempotencyKey string) ApiReturnRefund202309ReturnsReturnIdApprovePostRequest {
    r.idempotencyKey = &idempotencyKey
    return r
}
// 
func (r ApiReturnRefund202309ReturnsReturnIdApprovePostRequest) ShopCipher(shopCipher string) ApiReturnRefund202309ReturnsReturnIdApprovePostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiReturnRefund202309ReturnsReturnIdApprovePostRequest) ReturnRefund202309ApproveReturnRequestBody(returnRefund202309ApproveReturnRequestBody return_refund_v202309.ReturnRefund202309ApproveReturnRequestBody) ApiReturnRefund202309ReturnsReturnIdApprovePostRequest {
    r.returnRefund202309ApproveReturnRequestBody = &returnRefund202309ApproveReturnRequestBody
    return r
}
func (r ApiReturnRefund202309ReturnsReturnIdApprovePostRequest) Execute() (*return_refund_v202309.ReturnRefund202309ApproveReturnResponse, *http.Response, error) {
    return r.ApiService.ReturnRefund202309ReturnsReturnIdApprovePostExecute(r)
}

/*
ReturnRefund202309ReturnsReturnIdApprovePost ApproveReturn
Use this API to approve a buyer's return request.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param returnId The identifier of a specific return request.
@return ApiReturnRefund202309ReturnsReturnIdApprovePostRequest
*/
func (a *ReturnRefundV202309APIService) ReturnRefund202309ReturnsReturnIdApprovePost(ctx context.Context, returnId string) ApiReturnRefund202309ReturnsReturnIdApprovePostRequest {
    return ApiReturnRefund202309ReturnsReturnIdApprovePostRequest{
        ApiService: a,
        ctx: ctx,
        returnId: returnId,
    }
}

// Execute executes the request
//  @return ReturnRefund202309ApproveReturnResponse
func (a *ReturnRefundV202309APIService) ReturnRefund202309ReturnsReturnIdApprovePostExecute(r ApiReturnRefund202309ReturnsReturnIdApprovePostRequest) (*return_refund_v202309.ReturnRefund202309ApproveReturnResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *return_refund_v202309.ReturnRefund202309ApproveReturnResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReturnRefundV202309APIService.ReturnRefund202309ReturnsReturnIdApprovePost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/return_refund/202309/returns/{return_id}/approve"
    localVarPath = strings.Replace(localVarPath, "{"+"return_id"+"}", url.PathEscape(parameterValueToString(r.returnId, "returnId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.idempotencyKey != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "idempotency_key", r.idempotencyKey, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.returnRefund202309ApproveReturnRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReturnRefund202309ReturnsReturnIdRecordsGetRequest struct {
    ctx context.Context
    ApiService *ReturnRefundV202309APIService
    returnId string
    xTtsAccessToken *string
    contentType *string
    locale *string
    shopCipher *string
}

// 
func (r ApiReturnRefund202309ReturnsReturnIdRecordsGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiReturnRefund202309ReturnsReturnIdRecordsGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiReturnRefund202309ReturnsReturnIdRecordsGetRequest) ContentType(contentType string) ApiReturnRefund202309ReturnsReturnIdRecordsGetRequest {
    r.contentType = &contentType
    return r
}
// The BCP-47 locale codes for displaying the return reason, delimited by commas. Default: en-US Refer to [Locale codes](678e3a47bae28f030a8c7523) for the list of supported locale codes.
func (r ApiReturnRefund202309ReturnsReturnIdRecordsGetRequest) Locale(locale string) ApiReturnRefund202309ReturnsReturnIdRecordsGetRequest {
    r.locale = &locale
    return r
}
// 
func (r ApiReturnRefund202309ReturnsReturnIdRecordsGetRequest) ShopCipher(shopCipher string) ApiReturnRefund202309ReturnsReturnIdRecordsGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiReturnRefund202309ReturnsReturnIdRecordsGetRequest) Execute() (*return_refund_v202309.ReturnRefund202309GetReturnRecordsResponse, *http.Response, error) {
    return r.ApiService.ReturnRefund202309ReturnsReturnIdRecordsGetExecute(r)
}

/*
ReturnRefund202309ReturnsReturnIdRecordsGet GetReturnRecords
Use this API to get a list of return records.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param returnId A unique identifier for a TikTok Shop return request.
@return ApiReturnRefund202309ReturnsReturnIdRecordsGetRequest
*/
func (a *ReturnRefundV202309APIService) ReturnRefund202309ReturnsReturnIdRecordsGet(ctx context.Context, returnId string) ApiReturnRefund202309ReturnsReturnIdRecordsGetRequest {
    return ApiReturnRefund202309ReturnsReturnIdRecordsGetRequest{
        ApiService: a,
        ctx: ctx,
        returnId: returnId,
    }
}

// Execute executes the request
//  @return ReturnRefund202309GetReturnRecordsResponse
func (a *ReturnRefundV202309APIService) ReturnRefund202309ReturnsReturnIdRecordsGetExecute(r ApiReturnRefund202309ReturnsReturnIdRecordsGetRequest) (*return_refund_v202309.ReturnRefund202309GetReturnRecordsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *return_refund_v202309.ReturnRefund202309GetReturnRecordsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReturnRefundV202309APIService.ReturnRefund202309ReturnsReturnIdRecordsGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/return_refund/202309/returns/{return_id}/records"
    localVarPath = strings.Replace(localVarPath, "{"+"return_id"+"}", url.PathEscape(parameterValueToString(r.returnId, "returnId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.locale != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReturnRefund202309ReturnsReturnIdRejectPostRequest struct {
    ctx context.Context
    ApiService *ReturnRefundV202309APIService
    returnId string
    xTtsAccessToken *string
    contentType *string
    idempotencyKey *string
    shopCipher *string
    returnRefund202309RejectReturnRequestBody *return_refund_v202309.ReturnRefund202309RejectReturnRequestBody
}

// 
func (r ApiReturnRefund202309ReturnsReturnIdRejectPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiReturnRefund202309ReturnsReturnIdRejectPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiReturnRefund202309ReturnsReturnIdRejectPostRequest) ContentType(contentType string) ApiReturnRefund202309ReturnsReturnIdRejectPostRequest {
    r.contentType = &contentType
    return r
}
// The idempotency key is a unique value generated by the client which the server uses to recognize the same request. How you create unique keys is up to you, but we suggest using UUIDs, or another random string with enough entropy to avoid collisions. Idempotency keys can be up to 255 characters long.
func (r ApiReturnRefund202309ReturnsReturnIdRejectPostRequest) IdempotencyKey(idempotencyKey string) ApiReturnRefund202309ReturnsReturnIdRejectPostRequest {
    r.idempotencyKey = &idempotencyKey
    return r
}
// 
func (r ApiReturnRefund202309ReturnsReturnIdRejectPostRequest) ShopCipher(shopCipher string) ApiReturnRefund202309ReturnsReturnIdRejectPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiReturnRefund202309ReturnsReturnIdRejectPostRequest) ReturnRefund202309RejectReturnRequestBody(returnRefund202309RejectReturnRequestBody return_refund_v202309.ReturnRefund202309RejectReturnRequestBody) ApiReturnRefund202309ReturnsReturnIdRejectPostRequest {
    r.returnRefund202309RejectReturnRequestBody = &returnRefund202309RejectReturnRequestBody
    return r
}
func (r ApiReturnRefund202309ReturnsReturnIdRejectPostRequest) Execute() (*return_refund_v202309.ReturnRefund202309RejectReturnResponse, *http.Response, error) {
    return r.ApiService.ReturnRefund202309ReturnsReturnIdRejectPostExecute(r)
}

/*
ReturnRefund202309ReturnsReturnIdRejectPost RejectReturn
Use this API to reject a buyer's return or refund request.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param returnId The identifier of a specific return request.
@return ApiReturnRefund202309ReturnsReturnIdRejectPostRequest
*/
func (a *ReturnRefundV202309APIService) ReturnRefund202309ReturnsReturnIdRejectPost(ctx context.Context, returnId string) ApiReturnRefund202309ReturnsReturnIdRejectPostRequest {
    return ApiReturnRefund202309ReturnsReturnIdRejectPostRequest{
        ApiService: a,
        ctx: ctx,
        returnId: returnId,
    }
}

// Execute executes the request
//  @return ReturnRefund202309RejectReturnResponse
func (a *ReturnRefundV202309APIService) ReturnRefund202309ReturnsReturnIdRejectPostExecute(r ApiReturnRefund202309ReturnsReturnIdRejectPostRequest) (*return_refund_v202309.ReturnRefund202309RejectReturnResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *return_refund_v202309.ReturnRefund202309RejectReturnResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReturnRefundV202309APIService.ReturnRefund202309ReturnsReturnIdRejectPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/return_refund/202309/returns/{return_id}/reject"
    localVarPath = strings.Replace(localVarPath, "{"+"return_id"+"}", url.PathEscape(parameterValueToString(r.returnId, "returnId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.idempotencyKey != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "idempotency_key", r.idempotencyKey, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.returnRefund202309RejectReturnRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReturnRefund202309ReturnsSearchPostRequest struct {
    ctx context.Context
    ApiService *ReturnRefundV202309APIService
    xTtsAccessToken *string
    contentType *string
    sortField *string
    sortOrder *string
    pageSize *string
    pageToken *string
    shopCipher *string
    returnRefund202309SearchReturnsRequestBody *return_refund_v202309.ReturnRefund202309SearchReturnsRequestBody
}

// 
func (r ApiReturnRefund202309ReturnsSearchPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiReturnRefund202309ReturnsSearchPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiReturnRefund202309ReturnsSearchPostRequest) ContentType(contentType string) ApiReturnRefund202309ReturnsSearchPostRequest {
    r.contentType = &contentType
    return r
}
// The returned results will be sorted by the specified field.  Default: &#x60;create_time&#x60; Possible values: - &#x60;create_time&#x60; - &#x60;update_time&#x60;  Specify the order for sorting the returned results by using the &#x60;sort_order&#x60; parameter.
func (r ApiReturnRefund202309ReturnsSearchPostRequest) SortField(sortField string) ApiReturnRefund202309ReturnsSearchPostRequest {
    r.sortField = &sortField
    return r
}
// The sort order for the &#x60;sort_field&#x60; parameter. Default: ASC Possible values: - &#x60;ASC&#x60;: Ascending order - &#x60;DESC&#x60;: Descending order
func (r ApiReturnRefund202309ReturnsSearchPostRequest) SortOrder(sortOrder string) ApiReturnRefund202309ReturnsSearchPostRequest {
    r.sortOrder = &sortOrder
    return r
}
// The number of results to be returned per page. Default: 10. Valid range: [10-50].
func (r ApiReturnRefund202309ReturnsSearchPostRequest) PageSize(pageSize string) ApiReturnRefund202309ReturnsSearchPostRequest {
    r.pageSize = &pageSize
    return r
}
// An opaque token used to retrieve the next page of a paginated result set. Retrieve this value from the result of the &#x60;next_page_token&#x60; from a previous response. It is not needed for the first page.
func (r ApiReturnRefund202309ReturnsSearchPostRequest) PageToken(pageToken string) ApiReturnRefund202309ReturnsSearchPostRequest {
    r.pageToken = &pageToken
    return r
}
// 
func (r ApiReturnRefund202309ReturnsSearchPostRequest) ShopCipher(shopCipher string) ApiReturnRefund202309ReturnsSearchPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiReturnRefund202309ReturnsSearchPostRequest) ReturnRefund202309SearchReturnsRequestBody(returnRefund202309SearchReturnsRequestBody return_refund_v202309.ReturnRefund202309SearchReturnsRequestBody) ApiReturnRefund202309ReturnsSearchPostRequest {
    r.returnRefund202309SearchReturnsRequestBody = &returnRefund202309SearchReturnsRequestBody
    return r
}
func (r ApiReturnRefund202309ReturnsSearchPostRequest) Execute() (*return_refund_v202309.ReturnRefund202309SearchReturnsResponse, *http.Response, error) {
    return r.ApiService.ReturnRefund202309ReturnsSearchPostExecute(r)
}

/*
ReturnRefund202309ReturnsSearchPost SearchReturns
Use this API to retrieve one or more returns. This API supports filtering returns using query parameters. You can filter returns by create time, update time, return status, or return types. 

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiReturnRefund202309ReturnsSearchPostRequest
*/
func (a *ReturnRefundV202309APIService) ReturnRefund202309ReturnsSearchPost(ctx context.Context) ApiReturnRefund202309ReturnsSearchPostRequest {
    return ApiReturnRefund202309ReturnsSearchPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return ReturnRefund202309SearchReturnsResponse
func (a *ReturnRefundV202309APIService) ReturnRefund202309ReturnsSearchPostExecute(r ApiReturnRefund202309ReturnsSearchPostRequest) (*return_refund_v202309.ReturnRefund202309SearchReturnsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *return_refund_v202309.ReturnRefund202309SearchReturnsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReturnRefundV202309APIService.ReturnRefund202309ReturnsSearchPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/return_refund/202309/returns/search"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.sortField != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "sort_field", r.sortField, "")
    }
    if r.sortOrder != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "")
    }
    if r.pageSize != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    }
    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.returnRefund202309SearchReturnsRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
