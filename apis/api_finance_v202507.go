/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"

    "tiktokshop/open/sdk_golang/models/finance/v202507"
)


// FinanceV202507APIService FinanceV202507API service
type FinanceV202507APIService service

type ApiFinance202507OrdersUnsettledGetRequest struct {
    ctx context.Context
    ApiService *FinanceV202507APIService
    sortField *string
    xTtsAccessToken *string
    contentType *string
    pageToken *string
    pageSize *int64
    sortOrder *string
    searchTimeGe *int64
    searchTimeLt *int64
    shopCipher *string
}

// The returned results will be sorted by the specified field. Only supports &#x60;order_create_time&#x60;.
func (r ApiFinance202507OrdersUnsettledGetRequest) SortField(sortField string) ApiFinance202507OrdersUnsettledGetRequest {
    r.sortField = &sortField
    return r
}
// 
func (r ApiFinance202507OrdersUnsettledGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiFinance202507OrdersUnsettledGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFinance202507OrdersUnsettledGetRequest) ContentType(contentType string) ApiFinance202507OrdersUnsettledGetRequest {
    r.contentType = &contentType
    return r
}
// An opaque token used to retrieve the next page of a paginated result set. Retrieve this value from the result of the &#x60;next_page_token&#x60; from a previous response. It is not needed for the first page.
func (r ApiFinance202507OrdersUnsettledGetRequest) PageToken(pageToken string) ApiFinance202507OrdersUnsettledGetRequest {
    r.pageToken = &pageToken
    return r
}
// The number of results to be returned per page.  Default: 20 Valid range: [1-100]
func (r ApiFinance202507OrdersUnsettledGetRequest) PageSize(pageSize int64) ApiFinance202507OrdersUnsettledGetRequest {
    r.pageSize = &pageSize
    return r
}
// The sort order for the &#x60;sort_field&#x60; parameter.  Default: ASC  Possible values: - ASC: Ascending order - DESC: Descending order
func (r ApiFinance202507OrdersUnsettledGetRequest) SortOrder(sortOrder string) ApiFinance202507OrdersUnsettledGetRequest {
    r.sortOrder = &sortOrder
    return r
}
// Filter statements to show only those that are generated on or after the specified date and time. Unix timestamp. Note:statement_time_ge and statement_time_le together constitute the creation time filter condition. - If statement_time_ge is filled but statement_time_lt is empty, statement_time_lt will default to the current time. - If statement_time_lt is filled but statement_time_ge is empty, statement_time_ge will default to 20250101.
func (r ApiFinance202507OrdersUnsettledGetRequest) SearchTimeGe(searchTimeGe int64) ApiFinance202507OrdersUnsettledGetRequest {
    r.searchTimeGe = &searchTimeGe
    return r
}
// the search range&#39;s end time
func (r ApiFinance202507OrdersUnsettledGetRequest) SearchTimeLt(searchTimeLt int64) ApiFinance202507OrdersUnsettledGetRequest {
    r.searchTimeLt = &searchTimeLt
    return r
}
// 
func (r ApiFinance202507OrdersUnsettledGetRequest) ShopCipher(shopCipher string) ApiFinance202507OrdersUnsettledGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFinance202507OrdersUnsettledGetRequest) Execute() (*finance_v202507.Finance202507GetUnsettledTransactionsResponse, *http.Response, error) {
    return r.ApiService.Finance202507OrdersUnsettledGetExecute(r)
}

/*
Finance202507OrdersUnsettledGet GetUnsettledTransactions
This API allows the partner to retrieve a list of unsettled transactions (incl. Orders & Adjustments) generated by a seller, returning the detailed fee breakdown for a list of order ID and adjustment ID. 
For now, this API only returns transactions which were created after 2025.01.01. Once one transaction is settled, which won't be returned by this API anymore, please get from Get Statement Transaction API. 
**Pay attention to that all data returned through this API is an estimated amount which subject to change before settlement and can only used for seller's reference, final settlement amount per each transaction can only provided through statement related API.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiFinance202507OrdersUnsettledGetRequest
*/
func (a *FinanceV202507APIService) Finance202507OrdersUnsettledGet(ctx context.Context) ApiFinance202507OrdersUnsettledGetRequest {
    return ApiFinance202507OrdersUnsettledGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Finance202507GetUnsettledTransactionsResponse
func (a *FinanceV202507APIService) Finance202507OrdersUnsettledGetExecute(r ApiFinance202507OrdersUnsettledGetRequest) (*finance_v202507.Finance202507GetUnsettledTransactionsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *finance_v202507.Finance202507GetUnsettledTransactionsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FinanceV202507APIService.Finance202507OrdersUnsettledGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/finance/202507/orders/unsettled"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.sortField == nil {
        return localVarReturnValue, nil, reportError("sortField is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    if r.pageSize != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    }
    parameterAddToHeaderOrQuery(localVarQueryParams, "sort_field", r.sortField, "")
    if r.sortOrder != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "")
    }
    if r.searchTimeGe != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "search_time_ge", r.searchTimeGe, "")
    }
    if r.searchTimeLt != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "search_time_lt", r.searchTimeLt, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
