/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"

    "tiktokshop/open/sdk_golang/models/product/v202411"
)


// ProductV202411APIService ProductV202411API service
type ProductV202411APIService service

type ApiProduct202411ProductsDiagnoseOptimizePostRequest struct {
    ctx context.Context
    ApiService *ProductV202411APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    product202411DiagnoseandOptimizeProductRequestBody *product_v202411.Product202411DiagnoseandOptimizeProductRequestBody
}

// 
func (r ApiProduct202411ProductsDiagnoseOptimizePostRequest) XTtsAccessToken(xTtsAccessToken string) ApiProduct202411ProductsDiagnoseOptimizePostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiProduct202411ProductsDiagnoseOptimizePostRequest) ContentType(contentType string) ApiProduct202411ProductsDiagnoseOptimizePostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiProduct202411ProductsDiagnoseOptimizePostRequest) ShopCipher(shopCipher string) ApiProduct202411ProductsDiagnoseOptimizePostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiProduct202411ProductsDiagnoseOptimizePostRequest) Product202411DiagnoseandOptimizeProductRequestBody(product202411DiagnoseandOptimizeProductRequestBody product_v202411.Product202411DiagnoseandOptimizeProductRequestBody) ApiProduct202411ProductsDiagnoseOptimizePostRequest {
    r.product202411DiagnoseandOptimizeProductRequestBody = &product202411DiagnoseandOptimizeProductRequestBody
    return r
}
func (r ApiProduct202411ProductsDiagnoseOptimizePostRequest) Execute() (*product_v202411.Product202411DiagnoseandOptimizeProductResponse, *http.Response, error) {
    return r.ApiService.Product202411ProductsDiagnoseOptimizePostExecute(r)
}

/*
Product202411ProductsDiagnoseOptimizePost DiagnoseandOptimizeProduct
Diagnose products to obtain information that helps you to improve the product content, enhancing product visibility and customer trust. The returned information includes:
- Listing quality information (available only for the US market).
- Issues with the current product details and the overall recommendations
- Auto-generated optimization suggestions targeted for specific product fields, including the title, description, and image.
This API enables you to diagnose both live products (status: `ACTIVATE`)  and brand-new products not yet listed in TikTok Shop.
- To diagnose a **live product**, provide the `product_id` and `category_id` and leave all other product details blank.
- To diagnose a **brand-new product** not yet listed in TikTok Shop, omit the `product_id` and provide the product details as necessary.
- To diagnose a **product similar to an existing one**, provide the `product_id` and `category_id`, along with any new details. The diagnosis will combine the existing product's information with the new details you provide. For example, if you provide a new `title`, the diagnosis will use the new title instead of the existing one while keeping the other values from the product ID.
**Note**: 
- To diagnose multiple live products, use the [Product Information Issue Diagnosis API](665048f380b6b302e73917d9).
- This API focuses solely on optimizing product visibility and does not evaluate whether your product meets listing requirements. Quality issues identified by this API do not block your product from being listed. To verify listing requirements, use the [Check Product Listing API](650a0ee8f1fd3102b91c6493).

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiProduct202411ProductsDiagnoseOptimizePostRequest
*/
func (a *ProductV202411APIService) Product202411ProductsDiagnoseOptimizePost(ctx context.Context) ApiProduct202411ProductsDiagnoseOptimizePostRequest {
    return ApiProduct202411ProductsDiagnoseOptimizePostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Product202411DiagnoseandOptimizeProductResponse
func (a *ProductV202411APIService) Product202411ProductsDiagnoseOptimizePostExecute(r ApiProduct202411ProductsDiagnoseOptimizePostRequest) (*product_v202411.Product202411DiagnoseandOptimizeProductResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *product_v202411.Product202411DiagnoseandOptimizeProductResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductV202411APIService.Product202411ProductsDiagnoseOptimizePost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/product/202411/products/diagnose_optimize"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.product202411DiagnoseandOptimizeProductRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
