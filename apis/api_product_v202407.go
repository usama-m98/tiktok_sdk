/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"
    "reflect"

    "tiktokshop/open/sdk_golang/models/product/v202407"
)


// ProductV202407APIService ProductV202407API service
type ProductV202407APIService service

type ApiProduct202407ListingSchemasGetRequest struct {
    ctx context.Context
    ApiService *ProductV202407APIService
    categoryIds *[]int32
    xTtsAccessToken *string
    contentType *string
    locale *string
    categoryVersion *string
}

// The interface returns the field requirements for creating a product. By providing the leaf category ID, you can obtain the field information and input methods for the product creation requirements.
func (r ApiProduct202407ListingSchemasGetRequest) CategoryIds(categoryIds []int32) ApiProduct202407ListingSchemasGetRequest {
    r.categoryIds = &categoryIds
    return r
}
// 
func (r ApiProduct202407ListingSchemasGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiProduct202407ListingSchemasGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiProduct202407ListingSchemasGetRequest) ContentType(contentType string) ApiProduct202407ListingSchemasGetRequest {
    r.contentType = &contentType
    return r
}
// Category information will be returned in the corresponding language based on the specified locale. If no locale is provided, the default locale of the store will be used.  The currently supported locales include: en-GB, en-US, id-ID, ms-MY, th-TH, vi-VN, zh-CN. Use BCP-47 language codes, such as &#39;en-US&#39; or &#39;id&#39;. For more details, please refer to http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
func (r ApiProduct202407ListingSchemasGetRequest) Locale(locale string) ApiProduct202407ListingSchemasGetRequest {
    r.locale = &locale
    return r
}
// The version id of the category tree.The new version id is \&quot;v2\&quot; and will return data from our new 7-level category tree.The old version id is \&quot;v1\&quot; and will return data from the current 3-level category tree.The old version of category data will be given by default.
func (r ApiProduct202407ListingSchemasGetRequest) CategoryVersion(categoryVersion string) ApiProduct202407ListingSchemasGetRequest {
    r.categoryVersion = &categoryVersion
    return r
}
func (r ApiProduct202407ListingSchemasGetRequest) Execute() (*product_v202407.Product202407ListingSchemasResponse, *http.Response, error) {
    return r.ApiService.Product202407ListingSchemasGetExecute(r)
}

/*
Product202407ListingSchemasGet ListingSchemas
The interface returns the field requirements for creating a product. By providing the leaf category ID, you can obtain the field information and input methods for the product creation requirements.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiProduct202407ListingSchemasGetRequest
*/
func (a *ProductV202407APIService) Product202407ListingSchemasGet(ctx context.Context) ApiProduct202407ListingSchemasGetRequest {
    return ApiProduct202407ListingSchemasGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Product202407ListingSchemasResponse
func (a *ProductV202407APIService) Product202407ListingSchemasGetExecute(r ApiProduct202407ListingSchemasGetRequest) (*product_v202407.Product202407ListingSchemasResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *product_v202407.Product202407ListingSchemasResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductV202407APIService.Product202407ListingSchemasGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/product/202407/listing_schemas"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.categoryIds == nil {
        return localVarReturnValue, nil, reportError("categoryIds is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    {
        t := *r.categoryIds
        if reflect.TypeOf(t).Kind() == reflect.Slice {
            s := reflect.ValueOf(t)
            for i := 0; i < s.Len(); i++ {
                parameterAddToHeaderOrQuery(localVarQueryParams, "category_ids", s.Index(i).Interface(), "multi")
            }
        } else {
            parameterAddToHeaderOrQuery(localVarQueryParams, "category_ids", t, "multi")
        }
    }
    if r.locale != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
    }
    if r.categoryVersion != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "category_version", r.categoryVersion, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProduct202407ProductsCategoryUpgradeTaskPostRequest struct {
    ctx context.Context
    ApiService *ProductV202407APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiProduct202407ProductsCategoryUpgradeTaskPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiProduct202407ProductsCategoryUpgradeTaskPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiProduct202407ProductsCategoryUpgradeTaskPostRequest) ContentType(contentType string) ApiProduct202407ProductsCategoryUpgradeTaskPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiProduct202407ProductsCategoryUpgradeTaskPostRequest) ShopCipher(shopCipher string) ApiProduct202407ProductsCategoryUpgradeTaskPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiProduct202407ProductsCategoryUpgradeTaskPostRequest) Execute() (*product_v202407.Product202407CreateCategoryUpgradeTaskResponse, *http.Response, error) {
    return r.ApiService.Product202407ProductsCategoryUpgradeTaskPostExecute(r)
}

/*
Product202407ProductsCategoryUpgradeTaskPost CreateCategoryUpgradeTask
Create a task to upgrade live products (status: `ACTIVATE`) from a 3-level to a 7-level category tree.
The task runs for up to 2 hours, depending on the number of products. If the upgrade is incomplete after 2 hours, call the API again. To figure out which products' categories have not been upgraded, call the [Search Product API](https://partner.tiktokshop.com/docv2/page/65854ffb8f559302d8a6acda) and set "category_version" to "v1".
**Note**: You must wait at least 24 hours after a product goes live to successfully upgrade its category. If you call this API on the same day a new product goes live, the system will be unable to detect it. 

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiProduct202407ProductsCategoryUpgradeTaskPostRequest
*/
func (a *ProductV202407APIService) Product202407ProductsCategoryUpgradeTaskPost(ctx context.Context) ApiProduct202407ProductsCategoryUpgradeTaskPostRequest {
    return ApiProduct202407ProductsCategoryUpgradeTaskPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Product202407CreateCategoryUpgradeTaskResponse
func (a *ProductV202407APIService) Product202407ProductsCategoryUpgradeTaskPostExecute(r ApiProduct202407ProductsCategoryUpgradeTaskPostRequest) (*product_v202407.Product202407CreateCategoryUpgradeTaskResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *product_v202407.Product202407CreateCategoryUpgradeTaskResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductV202407APIService.Product202407ProductsCategoryUpgradeTaskPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/product/202407/products/category_upgrade_task"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProduct202407SizechartsSearchPostRequest struct {
    ctx context.Context
    ApiService *ProductV202407APIService
    pageSize *int64
    xTtsAccessToken *string
    contentType *string
    pageToken *string
    locales *[]string
    product202407SearchSizeChartsRequestBody *product_v202407.Product202407SearchSizeChartsRequestBody
}

// The number of results to be returned per page.  Valid range: [1-100]
func (r ApiProduct202407SizechartsSearchPostRequest) PageSize(pageSize int64) ApiProduct202407SizechartsSearchPostRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiProduct202407SizechartsSearchPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiProduct202407SizechartsSearchPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiProduct202407SizechartsSearchPostRequest) ContentType(contentType string) ApiProduct202407SizechartsSearchPostRequest {
    r.contentType = &contentType
    return r
}
// An opaque token used to retrieve the next page of a paginated result set. Retrieve this value from the result of the &#x60;next_page_token&#x60; from a previous response. It is not needed for the first page.
func (r ApiProduct202407SizechartsSearchPostRequest) PageToken(pageToken string) ApiProduct202407SizechartsSearchPostRequest {
    r.pageToken = &pageToken
    return r
}
// The BCP-47 locale codes for displaying the size charts. Default: The default locale of your shop. Possible values: - de-DE - en-GB - en-IE - en-US - es-ES - es-MX - fr-FR - id-ID - it-IT - ja-JP - ms-MY - pt-BR - th-TH - vi-VN - zh-CN
func (r ApiProduct202407SizechartsSearchPostRequest) Locales(locales []string) ApiProduct202407SizechartsSearchPostRequest {
    r.locales = &locales
    return r
}
func (r ApiProduct202407SizechartsSearchPostRequest) Product202407SearchSizeChartsRequestBody(product202407SearchSizeChartsRequestBody product_v202407.Product202407SearchSizeChartsRequestBody) ApiProduct202407SizechartsSearchPostRequest {
    r.product202407SearchSizeChartsRequestBody = &product202407SearchSizeChartsRequestBody
    return r
}
func (r ApiProduct202407SizechartsSearchPostRequest) Execute() (*product_v202407.Product202407SearchSizeChartsResponse, *http.Response, error) {
    return r.ApiService.Product202407SizechartsSearchPostExecute(r)
}

/*
Product202407SizechartsSearchPost SearchSizeCharts
Retrieve size charts that a seller has created.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiProduct202407SizechartsSearchPostRequest
*/
func (a *ProductV202407APIService) Product202407SizechartsSearchPost(ctx context.Context) ApiProduct202407SizechartsSearchPostRequest {
    return ApiProduct202407SizechartsSearchPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Product202407SearchSizeChartsResponse
func (a *ProductV202407APIService) Product202407SizechartsSearchPostExecute(r ApiProduct202407SizechartsSearchPostRequest) (*product_v202407.Product202407SearchSizeChartsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *product_v202407.Product202407SearchSizeChartsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductV202407APIService.Product202407SizechartsSearchPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/product/202407/sizecharts/search"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.pageSize == nil {
        return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    if r.locales != nil {
        t := *r.locales
        if reflect.TypeOf(t).Kind() == reflect.Slice {
            s := reflect.ValueOf(t)
            for i := 0; i < s.Len(); i++ {
                parameterAddToHeaderOrQuery(localVarQueryParams, "locales", s.Index(i).Interface(), "multi")
            }
        } else {
            parameterAddToHeaderOrQuery(localVarQueryParams, "locales", t, "multi")
        }
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.product202407SearchSizeChartsRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
