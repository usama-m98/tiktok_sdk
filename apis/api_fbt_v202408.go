/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"

    "tiktokshop/open/sdk_golang/models/fbt/v202408"
)


// FbtV202408APIService FbtV202408API service
type FbtV202408APIService service

type ApiFbt202408InventorySearchPostRequest struct {
    ctx context.Context
    ApiService *FbtV202408APIService
    pageSize *int32
    xTtsAccessToken *string
    contentType *string
    pageToken *string
    shopCipher *string
    fbt202408SearchFBTInventoryRequestBody *fbt_v202408.Fbt202408SearchFBTInventoryRequestBody
}

// The number of results to be returned per page.  Valid range: [1-100].
func (r ApiFbt202408InventorySearchPostRequest) PageSize(pageSize int32) ApiFbt202408InventorySearchPostRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiFbt202408InventorySearchPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiFbt202408InventorySearchPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFbt202408InventorySearchPostRequest) ContentType(contentType string) ApiFbt202408InventorySearchPostRequest {
    r.contentType = &contentType
    return r
}
// Pagination page token. It should be empty for the first page.
func (r ApiFbt202408InventorySearchPostRequest) PageToken(pageToken string) ApiFbt202408InventorySearchPostRequest {
    r.pageToken = &pageToken
    return r
}
// 
func (r ApiFbt202408InventorySearchPostRequest) ShopCipher(shopCipher string) ApiFbt202408InventorySearchPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFbt202408InventorySearchPostRequest) Fbt202408SearchFBTInventoryRequestBody(fbt202408SearchFBTInventoryRequestBody fbt_v202408.Fbt202408SearchFBTInventoryRequestBody) ApiFbt202408InventorySearchPostRequest {
    r.fbt202408SearchFBTInventoryRequestBody = &fbt202408SearchFBTInventoryRequestBody
    return r
}
func (r ApiFbt202408InventorySearchPostRequest) Execute() (*fbt_v202408.Fbt202408SearchFBTInventoryResponse, *http.Response, error) {
    return r.ApiService.Fbt202408InventorySearchPostExecute(r)
}

/*
Fbt202408InventorySearchPost SearchFBTInventory
This API is used to retrieve detailed inventory information for goods and matched SKUs, including sellable inventory, reserved inventory, unsellable inventory, and in-transit inventory at the warehouse level.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiFbt202408InventorySearchPostRequest
*/
func (a *FbtV202408APIService) Fbt202408InventorySearchPost(ctx context.Context) ApiFbt202408InventorySearchPostRequest {
    return ApiFbt202408InventorySearchPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Fbt202408SearchFBTInventoryResponse
func (a *FbtV202408APIService) Fbt202408InventorySearchPostExecute(r ApiFbt202408InventorySearchPostRequest) (*fbt_v202408.Fbt202408SearchFBTInventoryResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fbt_v202408.Fbt202408SearchFBTInventoryResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FbtV202408APIService.Fbt202408InventorySearchPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fbt/202408/inventory/search"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.pageSize == nil {
        return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.fbt202408SearchFBTInventoryRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFbt202408WarehousesGetRequest struct {
    ctx context.Context
    ApiService *FbtV202408APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiFbt202408WarehousesGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiFbt202408WarehousesGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFbt202408WarehousesGetRequest) ContentType(contentType string) ApiFbt202408WarehousesGetRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFbt202408WarehousesGetRequest) ShopCipher(shopCipher string) ApiFbt202408WarehousesGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFbt202408WarehousesGetRequest) Execute() (*fbt_v202408.Fbt202408GetFBTWarehouseListResponse, *http.Response, error) {
    return r.ApiService.Fbt202408WarehousesGetExecute(r)
}

/*
Fbt202408WarehousesGet GetFBTWarehouseList
This API is used to retrieve all Fulfilled by TikTok warehouse information including the warehouse name, warehouse address information, etc. The IDs of subscribed warehouses can be used to query inventory-related information.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiFbt202408WarehousesGetRequest
*/
func (a *FbtV202408APIService) Fbt202408WarehousesGet(ctx context.Context) ApiFbt202408WarehousesGetRequest {
    return ApiFbt202408WarehousesGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Fbt202408GetFBTWarehouseListResponse
func (a *FbtV202408APIService) Fbt202408WarehousesGetExecute(r ApiFbt202408WarehousesGetRequest) (*fbt_v202408.Fbt202408GetFBTWarehouseListResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fbt_v202408.Fbt202408GetFBTWarehouseListResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FbtV202408APIService.Fbt202408WarehousesGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fbt/202408/warehouses"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
