/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"
    "reflect"

    "tiktokshop/open/sdk_golang/models/fbt/v202409"
)


// FbtV202409APIService FbtV202409API service
type FbtV202409APIService service

type ApiFbt202409GoodsSearchPostRequest struct {
    ctx context.Context
    ApiService *FbtV202409APIService
    pageSize *int32
    xTtsAccessToken *string
    contentType *string
    pageToken *string
    shopCipher *string
    fbt202409SearchGoodsInfoRequestBody *fbt_v202409.Fbt202409SearchGoodsInfoRequestBody
}

// The number of results to be returned per page.  Valid range: [1-100].
func (r ApiFbt202409GoodsSearchPostRequest) PageSize(pageSize int32) ApiFbt202409GoodsSearchPostRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiFbt202409GoodsSearchPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiFbt202409GoodsSearchPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFbt202409GoodsSearchPostRequest) ContentType(contentType string) ApiFbt202409GoodsSearchPostRequest {
    r.contentType = &contentType
    return r
}
// An opaque token used to retrieve the next page of a paginated result set. Retrieve this value from the result of the &#x60;next_page_token&#x60; from a previous response. It is not needed for the first page.
func (r ApiFbt202409GoodsSearchPostRequest) PageToken(pageToken string) ApiFbt202409GoodsSearchPostRequest {
    r.pageToken = &pageToken
    return r
}
// 
func (r ApiFbt202409GoodsSearchPostRequest) ShopCipher(shopCipher string) ApiFbt202409GoodsSearchPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFbt202409GoodsSearchPostRequest) Fbt202409SearchGoodsInfoRequestBody(fbt202409SearchGoodsInfoRequestBody fbt_v202409.Fbt202409SearchGoodsInfoRequestBody) ApiFbt202409GoodsSearchPostRequest {
    r.fbt202409SearchGoodsInfoRequestBody = &fbt202409SearchGoodsInfoRequestBody
    return r
}
func (r ApiFbt202409GoodsSearchPostRequest) Execute() (*fbt_v202409.Fbt202409SearchGoodsInfoResponse, *http.Response, error) {
    return r.ApiService.Fbt202409GoodsSearchPostExecute(r)
}

/*
Fbt202409GoodsSearchPost SearchGoodsInfo
This API is used to retrieve a list of goods belonging to the merchant that meet the specified conditions. It returns detailed information about the goods, including their IDs, names, and other attributes, such as the goods-SKU relationship, dimensions, and weight as verified by the warehouse.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiFbt202409GoodsSearchPostRequest
*/
func (a *FbtV202409APIService) Fbt202409GoodsSearchPost(ctx context.Context) ApiFbt202409GoodsSearchPostRequest {
    return ApiFbt202409GoodsSearchPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Fbt202409SearchGoodsInfoResponse
func (a *FbtV202409APIService) Fbt202409GoodsSearchPostExecute(r ApiFbt202409GoodsSearchPostRequest) (*fbt_v202409.Fbt202409SearchGoodsInfoResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fbt_v202409.Fbt202409SearchGoodsInfoResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FbtV202409APIService.Fbt202409GoodsSearchPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fbt/202409/goods/search"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.pageSize == nil {
        return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.fbt202409SearchGoodsInfoRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFbt202409InboundOrdersGetRequest struct {
    ctx context.Context
    ApiService *FbtV202409APIService
    ids *[]string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// A list of inbound order IDs needs to be queried. The API will return the inbound order information for these IDs. Note: The inbound ID consists of a series of numbers without the \&quot;IBR\&quot; prefix. You can get the value in &#x60;data.inbound_order_id&#x60; in [Inbound FBT order status change](6708f866a88d1103246fed6a) webhook or in &#x60;data.inventory_records.order.id&#x60; in the response of [Search FBT Inventory Record](670d584ba83c5f030f3071e4).
func (r ApiFbt202409InboundOrdersGetRequest) Ids(ids []string) ApiFbt202409InboundOrdersGetRequest {
    r.ids = &ids
    return r
}
// 
func (r ApiFbt202409InboundOrdersGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiFbt202409InboundOrdersGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFbt202409InboundOrdersGetRequest) ContentType(contentType string) ApiFbt202409InboundOrdersGetRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFbt202409InboundOrdersGetRequest) ShopCipher(shopCipher string) ApiFbt202409InboundOrdersGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFbt202409InboundOrdersGetRequest) Execute() (*fbt_v202409.Fbt202409GetInboundOrderResponse, *http.Response, error) {
    return r.ApiService.Fbt202409InboundOrdersGetExecute(r)
}

/*
Fbt202409InboundOrdersGet GetInboundOrder
This API is used to retrieve the inbound order details including the planned inbound detail, actual inbound detail and inbound status, etc.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiFbt202409InboundOrdersGetRequest
*/
func (a *FbtV202409APIService) Fbt202409InboundOrdersGet(ctx context.Context) ApiFbt202409InboundOrdersGetRequest {
    return ApiFbt202409InboundOrdersGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Fbt202409GetInboundOrderResponse
func (a *FbtV202409APIService) Fbt202409InboundOrdersGetExecute(r ApiFbt202409InboundOrdersGetRequest) (*fbt_v202409.Fbt202409GetInboundOrderResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fbt_v202409.Fbt202409GetInboundOrderResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FbtV202409APIService.Fbt202409InboundOrdersGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fbt/202409/inbound_orders"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.ids == nil {
        return localVarReturnValue, nil, reportError("ids is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    {
        t := *r.ids
        if reflect.TypeOf(t).Kind() == reflect.Slice {
            s := reflect.ValueOf(t)
            for i := 0; i < s.Len(); i++ {
                parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "multi")
            }
        } else {
            parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "multi")
        }
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFbt202409MerchantsOnboardedRegionsGetRequest struct {
    ctx context.Context
    ApiService *FbtV202409APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiFbt202409MerchantsOnboardedRegionsGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiFbt202409MerchantsOnboardedRegionsGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFbt202409MerchantsOnboardedRegionsGetRequest) ContentType(contentType string) ApiFbt202409MerchantsOnboardedRegionsGetRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFbt202409MerchantsOnboardedRegionsGetRequest) ShopCipher(shopCipher string) ApiFbt202409MerchantsOnboardedRegionsGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFbt202409MerchantsOnboardedRegionsGetRequest) Execute() (*fbt_v202409.Fbt202409GetFBTMerchantOnboardedRegionsResponse, *http.Response, error) {
    return r.ApiService.Fbt202409MerchantsOnboardedRegionsGetExecute(r)
}

/*
Fbt202409MerchantsOnboardedRegionsGet GetFBTMerchantOnboardedRegions
This API verifies whether a seller is registered as a Fulfillment by TikTok (FBT) merchant. If the seller is onboarded, the API returns the regions where the merchant is authorized to operate under the FBT system.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiFbt202409MerchantsOnboardedRegionsGetRequest
*/
func (a *FbtV202409APIService) Fbt202409MerchantsOnboardedRegionsGet(ctx context.Context) ApiFbt202409MerchantsOnboardedRegionsGetRequest {
    return ApiFbt202409MerchantsOnboardedRegionsGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Fbt202409GetFBTMerchantOnboardedRegionsResponse
func (a *FbtV202409APIService) Fbt202409MerchantsOnboardedRegionsGetExecute(r ApiFbt202409MerchantsOnboardedRegionsGetRequest) (*fbt_v202409.Fbt202409GetFBTMerchantOnboardedRegionsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *fbt_v202409.Fbt202409GetFBTMerchantOnboardedRegionsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FbtV202409APIService.Fbt202409MerchantsOnboardedRegionsGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/fbt/202409/merchants/onboarded_regions"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
