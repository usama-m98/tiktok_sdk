/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"
    "strings"

    "tiktokshop/open/sdk_golang/models/finance/v202501"
)


// FinanceV202501APIService FinanceV202501API service
type FinanceV202501APIService service

type ApiFinance202501OrdersOrderIdStatementTransactionsGetRequest struct {
    ctx context.Context
    ApiService *FinanceV202501APIService
    orderId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiFinance202501OrdersOrderIdStatementTransactionsGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiFinance202501OrdersOrderIdStatementTransactionsGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFinance202501OrdersOrderIdStatementTransactionsGetRequest) ContentType(contentType string) ApiFinance202501OrdersOrderIdStatementTransactionsGetRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiFinance202501OrdersOrderIdStatementTransactionsGetRequest) ShopCipher(shopCipher string) ApiFinance202501OrdersOrderIdStatementTransactionsGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFinance202501OrdersOrderIdStatementTransactionsGetRequest) Execute() (*finance_v202501.Finance202501GetTransactionsbyOrderResponse, *http.Response, error) {
    return r.ApiService.Finance202501OrdersOrderIdStatementTransactionsGetExecute(r)
}

/*
Finance202501OrdersOrderIdStatementTransactionsGet GetTransactionsbyOrder
Retrieves the SKU-level details of an order transaction. This covers transactions related to sales, fees, commissions, shipping, taxes, and refunds.
Applicable for all regions' sellers. Only data after 2023-07-01 is available (Please note that for US cross-border sellers, data before 2025-04-30 is unavailable).

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param orderId The order ID in TikTok Shop.
@return ApiFinance202501OrdersOrderIdStatementTransactionsGetRequest
*/
func (a *FinanceV202501APIService) Finance202501OrdersOrderIdStatementTransactionsGet(ctx context.Context, orderId string) ApiFinance202501OrdersOrderIdStatementTransactionsGetRequest {
    return ApiFinance202501OrdersOrderIdStatementTransactionsGetRequest{
        ApiService: a,
        ctx: ctx,
        orderId: orderId,
    }
}

// Execute executes the request
//  @return Finance202501GetTransactionsbyOrderResponse
func (a *FinanceV202501APIService) Finance202501OrdersOrderIdStatementTransactionsGetExecute(r ApiFinance202501OrdersOrderIdStatementTransactionsGetRequest) (*finance_v202501.Finance202501GetTransactionsbyOrderResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *finance_v202501.Finance202501GetTransactionsbyOrderResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FinanceV202501APIService.Finance202501OrdersOrderIdStatementTransactionsGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/finance/202501/orders/{order_id}/statement_transactions"
    localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFinance202501StatementsStatementIdStatementTransactionsGetRequest struct {
    ctx context.Context
    ApiService *FinanceV202501APIService
    statementId string
    sortField *string
    xTtsAccessToken *string
    contentType *string
    pageToken *string
    sortOrder *string
    pageSize *interface{}
    shopCipher *string
}

// The returned results will be sorted by the specified field. Only supports &#x60;order_create_time&#x60;.
func (r ApiFinance202501StatementsStatementIdStatementTransactionsGetRequest) SortField(sortField string) ApiFinance202501StatementsStatementIdStatementTransactionsGetRequest {
    r.sortField = &sortField
    return r
}
// 
func (r ApiFinance202501StatementsStatementIdStatementTransactionsGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiFinance202501StatementsStatementIdStatementTransactionsGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiFinance202501StatementsStatementIdStatementTransactionsGetRequest) ContentType(contentType string) ApiFinance202501StatementsStatementIdStatementTransactionsGetRequest {
    r.contentType = &contentType
    return r
}
// An opaque token used to retrieve the next page of a paginated result set. Retrieve this value from the result of the &#x60;next_page_token&#x60; from a previous response. It is not needed for the first page.
func (r ApiFinance202501StatementsStatementIdStatementTransactionsGetRequest) PageToken(pageToken string) ApiFinance202501StatementsStatementIdStatementTransactionsGetRequest {
    r.pageToken = &pageToken
    return r
}
// The sort order for the &#x60;sort_field&#x60; parameter.  Default: ASC  Possible values: - ASC: Ascending order - DESC: Descending order
func (r ApiFinance202501StatementsStatementIdStatementTransactionsGetRequest) SortOrder(sortOrder string) ApiFinance202501StatementsStatementIdStatementTransactionsGetRequest {
    r.sortOrder = &sortOrder
    return r
}
// The number of results to be returned per page.  Default: 20 Valid range: [1-100]
func (r ApiFinance202501StatementsStatementIdStatementTransactionsGetRequest) PageSize(pageSize interface{}) ApiFinance202501StatementsStatementIdStatementTransactionsGetRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiFinance202501StatementsStatementIdStatementTransactionsGetRequest) ShopCipher(shopCipher string) ApiFinance202501StatementsStatementIdStatementTransactionsGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiFinance202501StatementsStatementIdStatementTransactionsGetRequest) Execute() (*finance_v202501.Finance202501GetTransactionsbyStatementResponse, *http.Response, error) {
    return r.ApiService.Finance202501StatementsStatementIdStatementTransactionsGetExecute(r)
}

/*
Finance202501StatementsStatementIdStatementTransactionsGet GetTransactionsbyStatement
Retrieves the details of a statement, including the transactions, which can be a standard order transaction, an adjustment transaction, or a reserve-related transaction. For the SKU-level details of an order transaction, refer to [Get Transactions by Order](650a6734defece02be67d724).
Applicable for all regions' sellers. Only data after 2023-07-01 is available (Please note that for US cross-border sellers, data before 2025-04-30 is unavailable).

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param statementId The unique id of statement
@return ApiFinance202501StatementsStatementIdStatementTransactionsGetRequest
*/
func (a *FinanceV202501APIService) Finance202501StatementsStatementIdStatementTransactionsGet(ctx context.Context, statementId string) ApiFinance202501StatementsStatementIdStatementTransactionsGetRequest {
    return ApiFinance202501StatementsStatementIdStatementTransactionsGetRequest{
        ApiService: a,
        ctx: ctx,
        statementId: statementId,
    }
}

// Execute executes the request
//  @return Finance202501GetTransactionsbyStatementResponse
func (a *FinanceV202501APIService) Finance202501StatementsStatementIdStatementTransactionsGetExecute(r ApiFinance202501StatementsStatementIdStatementTransactionsGetRequest) (*finance_v202501.Finance202501GetTransactionsbyStatementResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *finance_v202501.Finance202501GetTransactionsbyStatementResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FinanceV202501APIService.Finance202501StatementsStatementIdStatementTransactionsGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/finance/202501/statements/{statement_id}/statement_transactions"
    localVarPath = strings.Replace(localVarPath, "{"+"statement_id"+"}", url.PathEscape(parameterValueToString(r.statementId, "statementId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.sortField == nil {
        return localVarReturnValue, nil, reportError("sortField is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    parameterAddToHeaderOrQuery(localVarQueryParams, "sort_field", r.sortField, "")
    if r.sortOrder != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "")
    }
    if r.pageSize != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
