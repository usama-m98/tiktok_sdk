/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"

    "tiktokshop/open/sdk_golang/models/product/v202312"
)


// ProductV202312APIService ProductV202312API service
type ProductV202312APIService service

type ApiProduct202312GlobalProductsSearchPostRequest struct {
    ctx context.Context
    ApiService *ProductV202312APIService
    pageSize *int32
    xTtsAccessToken *string
    contentType *string
    pageToken *string
    product202312SearchGlobalProductsRequestBody *product_v202312.Product202312SearchGlobalProductsRequestBody
}

// The number of results to be returned per page.  Valid range: [1-100] 
func (r ApiProduct202312GlobalProductsSearchPostRequest) PageSize(pageSize int32) ApiProduct202312GlobalProductsSearchPostRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiProduct202312GlobalProductsSearchPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiProduct202312GlobalProductsSearchPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiProduct202312GlobalProductsSearchPostRequest) ContentType(contentType string) ApiProduct202312GlobalProductsSearchPostRequest {
    r.contentType = &contentType
    return r
}
// An opaque token used to retrieve the next page of a paginated result set. Retrieve this value from the result of the &#x60;next_page_token&#x60; from a previous response. It is not needed for the first page.
func (r ApiProduct202312GlobalProductsSearchPostRequest) PageToken(pageToken string) ApiProduct202312GlobalProductsSearchPostRequest {
    r.pageToken = &pageToken
    return r
}
func (r ApiProduct202312GlobalProductsSearchPostRequest) Product202312SearchGlobalProductsRequestBody(product202312SearchGlobalProductsRequestBody product_v202312.Product202312SearchGlobalProductsRequestBody) ApiProduct202312GlobalProductsSearchPostRequest {
    r.product202312SearchGlobalProductsRequestBody = &product202312SearchGlobalProductsRequestBody
    return r
}
func (r ApiProduct202312GlobalProductsSearchPostRequest) Execute() (*product_v202312.Product202312SearchGlobalProductsResponse, *http.Response, error) {
    return r.ApiService.Product202312GlobalProductsSearchPostExecute(r)
}

/*
Product202312GlobalProductsSearchPost SearchGlobalProducts
Retrieve a list of global products that meet the specified conditions. 
This API will only return the key product properties. You can pass a returned global product ID to the [Get Global Product API](https://partner.tiktokshop.com/docv2/page/6509e2b0bace3e02b7490c96) to obtain more details about the product.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiProduct202312GlobalProductsSearchPostRequest
*/
func (a *ProductV202312APIService) Product202312GlobalProductsSearchPost(ctx context.Context) ApiProduct202312GlobalProductsSearchPostRequest {
    return ApiProduct202312GlobalProductsSearchPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Product202312SearchGlobalProductsResponse
func (a *ProductV202312APIService) Product202312GlobalProductsSearchPostExecute(r ApiProduct202312GlobalProductsSearchPostRequest) (*product_v202312.Product202312SearchGlobalProductsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *product_v202312.Product202312SearchGlobalProductsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductV202312APIService.Product202312GlobalProductsSearchPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/product/202312/global_products/search"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.pageSize == nil {
        return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.product202312SearchGlobalProductsRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProduct202312PrerequisitesGetRequest struct {
    ctx context.Context
    ApiService *ProductV202312APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiProduct202312PrerequisitesGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiProduct202312PrerequisitesGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiProduct202312PrerequisitesGetRequest) ContentType(contentType string) ApiProduct202312PrerequisitesGetRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiProduct202312PrerequisitesGetRequest) ShopCipher(shopCipher string) ApiProduct202312PrerequisitesGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiProduct202312PrerequisitesGetRequest) Execute() (*product_v202312.Product202312CheckListingPrerequisitesResponse, *http.Response, error) {
    return r.ApiService.Product202312PrerequisitesGetExecute(r)
}

/*
Product202312PrerequisitesGet CheckListingPrerequisites
Check if a TikTok shop is ready to list products.
Each shop needs to satisfy a series of TikTok Shop requirements before you can start listing products. Before you proceed to list products, use this API to check if your shop has satisfied all requirements.
**Tip**: We recommend that you run this check before any bulk updates to avoid listing issues. For example, sellers may change the delivery option to "Shipped by seller" but fail to add a shipping template, thus blocking the shop from listing products. In this case, the API would return `is_failed=true` for the `SHIPPING_TEMPLATE` check item and you can prompt the seller to fix the problem. 

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiProduct202312PrerequisitesGetRequest
*/
func (a *ProductV202312APIService) Product202312PrerequisitesGet(ctx context.Context) ApiProduct202312PrerequisitesGetRequest {
    return ApiProduct202312PrerequisitesGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Product202312CheckListingPrerequisitesResponse
func (a *ProductV202312APIService) Product202312PrerequisitesGetExecute(r ApiProduct202312PrerequisitesGetRequest) (*product_v202312.Product202312CheckListingPrerequisitesResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *product_v202312.Product202312CheckListingPrerequisitesResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductV202312APIService.Product202312PrerequisitesGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/product/202312/prerequisites"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProduct202312ProductsSearchPostRequest struct {
    ctx context.Context
    ApiService *ProductV202312APIService
    pageSize *int32
    xTtsAccessToken *string
    contentType *string
    pageToken *string
    shopCipher *string
    product202312SearchProductsRequestBody *product_v202312.Product202312SearchProductsRequestBody
}

// The number of results to be returned per page.  Valid range: [1-100]
func (r ApiProduct202312ProductsSearchPostRequest) PageSize(pageSize int32) ApiProduct202312ProductsSearchPostRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiProduct202312ProductsSearchPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiProduct202312ProductsSearchPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiProduct202312ProductsSearchPostRequest) ContentType(contentType string) ApiProduct202312ProductsSearchPostRequest {
    r.contentType = &contentType
    return r
}
// An opaque token used to retrieve the next page of a paginated result set. Retrieve this value from the result of the &#x60;next_page_token&#x60; from a previous response. It is not needed for the first page.
func (r ApiProduct202312ProductsSearchPostRequest) PageToken(pageToken string) ApiProduct202312ProductsSearchPostRequest {
    r.pageToken = &pageToken
    return r
}
// 
func (r ApiProduct202312ProductsSearchPostRequest) ShopCipher(shopCipher string) ApiProduct202312ProductsSearchPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiProduct202312ProductsSearchPostRequest) Product202312SearchProductsRequestBody(product202312SearchProductsRequestBody product_v202312.Product202312SearchProductsRequestBody) ApiProduct202312ProductsSearchPostRequest {
    r.product202312SearchProductsRequestBody = &product202312SearchProductsRequestBody
    return r
}
func (r ApiProduct202312ProductsSearchPostRequest) Execute() (*product_v202312.Product202312SearchProductsResponse, *http.Response, error) {
    return r.ApiService.Product202312ProductsSearchPostExecute(r)
}

/*
Product202312ProductsSearchPost SearchProducts
Retrieve a list of products that meet the specified conditions. 
This API will only return the key product properties. You can pass a returned product ID to the [Get Product API](https://partner.tiktokshop.com/docv2/page/6509d85b4a0bb702c057fdda) to obtain more details about the product.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiProduct202312ProductsSearchPostRequest
*/
func (a *ProductV202312APIService) Product202312ProductsSearchPost(ctx context.Context) ApiProduct202312ProductsSearchPostRequest {
    return ApiProduct202312ProductsSearchPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Product202312SearchProductsResponse
func (a *ProductV202312APIService) Product202312ProductsSearchPostExecute(r ApiProduct202312ProductsSearchPostRequest) (*product_v202312.Product202312SearchProductsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *product_v202312.Product202312SearchProductsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductV202312APIService.Product202312ProductsSearchPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/product/202312/products/search"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.pageSize == nil {
        return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.product202312SearchProductsRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
